<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bilderaufbereiter für die LCD-Brosche</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 880px; margin: 2rem auto; padding: 0 1rem; }
    header { margin-bottom: 1rem; }
    h1 { font-size: clamp(1.4rem, 2.5vw, 2rem); margin: 0 0 .25rem; }
    .muted { opacity: .75; }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; margin: .75rem 0; }
    .preview { position: relative; display: block; width: 358.2857142857px; height: 350.0571428571px; margin: 2.5rem auto 0; }
    .preview__viewport { position: absolute; top: 43.7142857143px; left: 55.0285714286px; width: 240px; height: 240px; border-radius: 50%; overflow: hidden; border: 1px solid #c9c9c9; box-shadow: 0 1px 8px rgba(0,0,0,.08); background: #fff; }
    .preview__viewport::after { content: ""; position: absolute; inset: 0; border-radius: 50%; pointer-events: none; box-shadow: inset 0 0 0 1px rgba(0,0,0,.12); }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: default; }
    .preview__mask { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; object-fit: cover; }
    button, select, input[type="number"], input[type="file"] { padding: .55rem .8rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: canvas; }
    button[disabled] { opacity: .5; }
    .actions { margin: 1.5rem 0 0; }
    footer { margin-top: 2rem; font-size: .9rem; }
    code { background: rgba(127,127,127,.15); padding: .1rem .3rem; border-radius: .3rem; }
  </style>
</head>
<body>
  <header>
    <h1>Bilderaufbereiter für die LCD-Brosche</h1>
    <p class="muted">Alles läuft lokal im Browser. Ergebnis ist ein 240×240-Pixel-JPEG im <b>Baseline-DCT</b>-Format (kein „progressive“).</p>
  </header>

  <div class="row">
    <input id="file" type="file" accept="image/*" />
    <label>Zuschnitt:
      <select id="mode">
        <option value="cover">Zentriert zuschneiden (füllend)</option>
        <option value="contain">Einpassen (weiß auffüllen)</option>
      </select>
    </label>
    <label>Qualität:
      <input id="quality" type="number" min="10" max="100" value="92" style="width:5rem"> %
    </label>
  </div>

  <div class="preview">
    <div class="preview__viewport">
      <canvas id="cv" width="240" height="240"></canvas>
    </div>
    <img class="preview__mask" src="./LCD-Brosche-maske.png" alt="Maske der LCD-Brosche" />
  </div>

  <div class="actions">
    <button id="save" disabled>Als JPEG speichern</button>
  </div>

  <script type="module">
    // --- Import der MozJPEG-WASM-Codec-Factory (jSquash, auf UNPKG gehostet) ---
    // Dokumentation/Quelle: https://github.com/jamsinclair/jSquash (encode API) –
    // und Typdefinitionen der Optionen (mozjpeg_enc.d.ts)
    const moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;

    // Fallback: Wenn du die WASM/JS lokal ausliefern willst, lege sie in ./mozjpeg/ ab
    // und ersetze die URL oben durch: './mozjpeg/mozjpeg_enc.js'
    // (Achte darauf, dass mozjpeg_enc.wasm im selben Ordner liegt.)

    const fileInput = document.getElementById('file');
    const modeSel   = document.getElementById('mode');
    const qInput    = document.getElementById('quality');
    const btnSave   = document.getElementById('save');
    const cv        = document.getElementById('cv');
    const ctx       = cv.getContext('2d', { willReadFrequently: true });

    let currentBitmap = null;
    let moz = null;
    let coverPan = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };

    // JPEG header scan to verify non-progressive:
    // Baseline SOF0 marker = 0xFFC0, Progressive SOF2 = 0xFFC2
    function isProgressiveJPEG(u8) {
      for (let i = 0; i < u8.length - 1; i++) {
        if (u8[i] === 0xFF) {
          const code = u8[i + 1];
          if (code === 0xC2) return true;   // SOF2
          if (code === 0xDA) break;         // SOS reached -> stop scanning
        }
      }
      return false;
    }

    function clearCanvas() {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, cv.width, cv.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, cv.width, cv.height);
      ctx.restore();
    }

    function resetCoverPan() {
      coverPan.x = 0;
      coverPan.y = 0;
    }

    async function loadImageBitmap(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      await img.decode();
      const bmp = await createImageBitmap(img);
      URL.revokeObjectURL(url);
      return bmp;
    }

    function clampCoverPanValues(bmp, x, y) {
      if (!bmp) return { x: 0, y: 0 };
      const T = 240;
      const s = Math.max(T / bmp.width, T / bmp.height);
      const w = bmp.width * s;
      const h = bmp.height * s;
      const maxPanX = Math.max(0, (w - T) / 2);
      const maxPanY = Math.max(0, (h - T) / 2);
      return {
        x: Math.max(-maxPanX, Math.min(maxPanX, x)),
        y: Math.max(-maxPanY, Math.min(maxPanY, y))
      };
    }

    function updateCanvasCursor() {
      if (currentBitmap && modeSel.value === 'cover') {
        cv.style.cursor = isDragging ? 'grabbing' : 'grab';
      } else {
        cv.style.cursor = 'default';
      }
    }

    function drawScaled(bmp) {
      clearCanvas();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const T = 240, sw = bmp.width, sh = bmp.height;
      if (modeSel.value === 'cover') {
        const s = Math.max(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const clamped = clampCoverPanValues(bmp, coverPan.x, coverPan.y);
        coverPan.x = clamped.x;
        coverPan.y = clamped.y;
        const dx = (T - w) / 2 + coverPan.x;
        const dy = (T - h) / 2 + coverPan.y;
        ctx.drawImage(bmp, dx, dy, w, h);
      } else {
        const s = Math.min(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const dx = (T - w) / 2, dy = (T - h) / 2;
        ctx.drawImage(bmp, dx, dy, w, h);
      }
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      currentBitmap = await loadImageBitmap(file);
      resetCoverPan();
      drawScaled(currentBitmap);
      if (!moz) {
        try {
          moz = await moduleFactory(); // lädt automatisch mozjpeg_enc.wasm
          console.log('MozJPEG (WASM) bereit.');
        } catch (err) {
          console.error(err);
          alert('Konnte MozJPEG-WASM nicht laden. Prüfe Internetverbindung oder nutze lokale Dateien in ./mozjpeg/');
          return;
        }
      }
      btnSave.disabled = false;
      updateCanvasCursor();
    });

    modeSel.addEventListener('change', () => {
      if (isDragging) {
        isDragging = false;
      }
      updateCanvasCursor();
      if (currentBitmap) drawScaled(currentBitmap);
    });

    cv.addEventListener('pointerdown', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      e.preventDefault();
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      panStart = { x: coverPan.x, y: coverPan.y };
      try {
        cv.setPointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    });

    cv.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      const nextPan = clampCoverPanValues(currentBitmap, panStart.x + dx, panStart.y + dy);
      coverPan.x = nextPan.x;
      coverPan.y = nextPan.y;
      drawScaled(currentBitmap);
    });

    function endDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      try {
        cv.releasePointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    }

    cv.addEventListener('pointerup', endDrag);
    cv.addEventListener('pointercancel', endDrag);

    btnSave.addEventListener('click', async () => {
      if (!moz) {
        alert('MozJPEG ist noch nicht initialisiert.');
        return;
      }
      const { data } = ctx.getImageData(0, 0, cv.width, cv.height);
      const quality = Math.min(100, Math.max(10, parseInt(qInput.value, 10) || 92));

      const opts = {
        quality,
        baseline: true,          // <<< sicherstellen: Baseline-DCT
        progressive: false,      // <<< sicherstellen: NICHT progressiv
        arithmetic: false,
        optimize_coding: true,
        smoothing: 0,
        color_space: 3,          // MozJpegColorSpace.YCbCr
        quant_table: 3,          // "HVS Best" (wie Squoosh-Default)
        trellis_multipass: false,
        trellis_opt_zero: false,
        trellis_opt_table: false,
        trellis_loops: 1,
        auto_subsample: false,
        chroma_subsample: 2,       // erzwingt 4:2:0 (YCbCr) für die Brosche
        separate_chroma_quality: false,
        chroma_quality: quality
      };

      try {
        const jpegU8 = moz.encode(data, 240, 240, opts);
        // Verifizieren: nicht progressiv
        if (isProgressiveJPEG(jpegU8)) {
          alert('Warnung: Der erzeugte JPEG scheint progressiv zu sein – das sollte nicht passieren.');
        }
        const blob = new Blob([jpegU8], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'image_240x240.jpg';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
        alert('Fehler beim JPEG-Encode: ' + (err?.message || err));
      }
    });
  </script>
</body>
</html>

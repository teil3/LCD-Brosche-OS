<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bilderaufbereiter für die LCD-Brosche</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 880px; margin: 2rem auto; padding: 0 1rem; background: #f8f9fb; color: #1f252d; }
    header { margin-bottom: 1rem; }
    h1 { font-size: clamp(1.4rem, 2.5vw, 2rem); margin: 0 0 .25rem; }
    .muted { opacity: .75; }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; margin: .75rem 0; }
    .preview { position: relative; display: block; width: 358.2857142857px; height: 350.0571428571px; margin: 2.5rem auto 0; }
    .preview__viewport { position: absolute; top: 43.7142857143px; left: 55.0285714286px; width: 240px; height: 240px; border-radius: 50%; overflow: hidden; border: 1px solid #c9c9c9; box-shadow: 0 1px 8px rgba(0,0,0,.08); background: #fff; }
    .preview__viewport::after { content: ""; position: absolute; inset: 0; border-radius: 50%; pointer-events: none; box-shadow: inset 0 0 0 1px rgba(0,0,0,.12); }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: default; }
    .preview__mask { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; object-fit: cover; }
    button, select, input[type="number"], input[type="file"] { padding: .55rem .8rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: #ffffff; color: inherit; }
    button[disabled] { opacity: .5; }
    .actions { margin: 1.5rem 0 0; }
    footer { margin-top: 2rem; font-size: .9rem; }
    code { background: rgba(127,127,127,.15); padding: .1rem .3rem; border-radius: .3rem; }
    .drop-overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; padding: 2rem; color: #1f4d8f; font-weight: 600; font-size: clamp(1.1rem, 2.5vw, 1.6rem); background: rgba(74,144,226,.14); border: 2px dashed rgba(74,144,226,.6); pointer-events: none; opacity: 0; transform: scale(1.02); transition: opacity .2s ease, transform .2s ease; z-index: 999; }
    body.drop-active .drop-overlay { opacity: 1; transform: scale(1); }
    body.drop-active .preview__viewport { border-color: #4a90e2; box-shadow: 0 0 0 4px rgba(74,144,226,.25); }
    .drop-hint { margin: -.25rem 0 0; font-size: .9rem; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
    .file-picker { display: flex; align-items: center; gap: .6rem; flex-wrap: wrap; }
    .file-picker__button { display: inline-flex; align-items: center; justify-content: center; padding: .55rem .9rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: canvas; cursor: pointer; font-weight: 400; }
    .file-picker__button:focus-visible { outline: 2px solid #4a90e2; outline-offset: 2px; }
  </style>
</head>
<body>
  <div class="drop-overlay" aria-hidden="true">Bilddatei hier ablegen, um sie zu laden</div>
  <header>
    <h1>Bilderaufbereiter für die LCD-Brosche</h1>
    <p class="muted">Bereitet Bilder für die Anzeige auf der Brosche vor.</p>
  </header>

  <div class="row">
    <div class="file-picker">
      <label class="file-picker__button" for="file">Bild auswählen…</label>
      <input id="file" type="file" accept="image/*" class="visually-hidden" />
    </div>
    <label>Zuschnitt:
      <select id="mode">
        <option value="cover">Zentriert zuschneiden (füllend)</option>
        <option value="contain">Einpassen (weiß auffüllen)</option>
      </select>
    </label>
    <label>Qualität:
      <input id="quality" type="number" min="10" max="100" value="92" style="width:5rem"> %
    </label>
  </div>
  <p class="muted drop-hint">Tipp: Ziehe eine Bilddatei irgendwo auf diese Seite – sie wird automatisch geladen.</p>

  <div class="preview">
    <div class="preview__viewport">
      <canvas id="cv" width="240" height="240"></canvas>
    </div>
    <img class="preview__mask" src="./LCD-Brosche-maske.png" alt="Maske der LCD-Brosche" />
  </div>

  <div class="actions">
    <button id="save" disabled>Als JPEG speichern</button>
    <button id="send-ble" disabled>Per BLE senden</button>
    <p id="ble-status" class="muted" aria-live="polite"></p>
    <p class="muted" id="ble-hint">Hinweis: Auf der Brosche den BLE-Empfangsmodus aktivieren (BTN2 lang drücken, bis "BLE" angezeigt wird).</p>
  </div>

  <script type="module">
    // --- Import der MozJPEG-WASM-Codec-Factory (jSquash, auf UNPKG gehostet) ---
    // Dokumentation/Quelle: https://github.com/jamsinclair/jSquash (encode API) –
    // und Typdefinitionen der Optionen (mozjpeg_enc.d.ts)
    const moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;
    //const moduleFactory = (await import('./mozjpeg/mozjpeg_enc.js?module')).default;

    // Fallback: Wenn du die WASM/JS lokal ausliefern willst, lege sie in ./mozjpeg/ ab
    // und ersetze die URL oben durch: './mozjpeg/mozjpeg_enc.js'
    // (Achte darauf, dass mozjpeg_enc.wasm im selben Ordner liegt.)

    const fileInput = document.getElementById('file');
    const modeSel   = document.getElementById('mode');
    const qInput    = document.getElementById('quality');
    const btnSave   = document.getElementById('save');
    const btnBle    = document.getElementById('send-ble');
    const bleStatus = document.getElementById('ble-status');
    const cv        = document.getElementById('cv');
    const ctx       = cv.getContext('2d', { willReadFrequently: true });
    const BLE_UUIDS = {
      service: '12345678-1234-1234-1234-1234567890ab',
      chunk:   'abcd0001-1234-1234-1234-1234567890ab',
      control: 'abcd0002-1234-1234-1234-1234567890ab'
    };
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    let currentBitmap = null;
    let moz = null;
    let mozReady = false;
    let coverPan = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };
    let dropDepth = 0;
    let currentDownloadName = 'image_240.jpg';
    let bleSending = false;

    const secureContextHosts = new Set(['localhost', '127.0.0.1', '::1']);
    const secureContext = window.isSecureContext || secureContextHosts.has(location.hostname);
    const bleAvailable = 'bluetooth' in navigator;
    const bleSupported = secureContext && bleAvailable;

    function setBleStatus(text) {
      if (!bleStatus) return;
      bleStatus.textContent = text || '';
    }

    function updateActionButtons() {
      const ready = !!currentBitmap && mozReady;
      btnSave.disabled = !ready || bleSending;
      btnBle.disabled = !ready || !bleSupported || bleSending;
    }

    function sanitizeFilenameForBle(name) {
      const fallback = 'ble_image.jpg';
      if (!name) return fallback;
      let base = name.split(/[\\/]/).pop() || fallback;
      base = base.toLowerCase();
      let out = '';
      for (const ch of base) {
        if ((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch === '-' || ch === '_' || ch === '.') {
          out += ch;
        } else if (ch === ' ') {
          out += '_';
        }
        if (out.length >= 60) break;
      }
      if (!out) out = fallback;
      if (out.startsWith('.')) out = out.substring(1) || fallback;
      if (!out.endsWith('.jpg') && !out.endsWith('.jpeg')) {
        out += '.jpg';
      }
      if (out.length > 60) {
        const idx = out.lastIndexOf('.');
        const ext = idx >= 0 ? out.slice(idx) : '.jpg';
        const stem = idx >= 0 ? out.slice(0, idx) : out;
        out = stem.slice(0, Math.max(1, 60 - ext.length)) + ext;
      }
      return out;
    }

    function humanReadableSize(bytes) {
      if (!Number.isFinite(bytes)) return '0 B';
      if (bytes < 1024) return `${bytes} B`;
      const kb = bytes / 1024;
      const rounded = Math.round(kb * 10) / 10;
      return `${rounded.toFixed(rounded % 1 === 0 ? 0 : 1)} KB`;
    }

    async function encodeCurrentImage() {
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        throw new Error('Kein Bild geladen');
      }
      const ready = await initMozIfNeeded();
      if (!ready || !moz) {
        throw new Error('JPEG-Codec nicht verfügbar');
      }
      const { data } = ctx.getImageData(0, 0, cv.width, cv.height);
      const quality = Math.min(100, Math.max(10, parseInt(qInput.value, 10) || 92));
      const opts = {
        quality,
        baseline: true,
        progressive: false,
        arithmetic: false,
        optimize_coding: true,
        smoothing: 0,
        color_space: 3,
        quant_table: 3,
        trellis_multipass: false,
        trellis_opt_zero: false,
        trellis_opt_table: false,
        trellis_loops: 1,
        auto_subsample: false,
        chroma_subsample: 2,
        separate_chroma_quality: false,
        chroma_quality: quality
      };

      try {
        const jpegU8 = moz.encode(data, 240, 240, opts);
        if (isProgressiveJPEG(jpegU8)) {
          alert('Warnung: Der erzeugte JPEG scheint progressiv zu sein.');
        }
        return {
          bytes: jpegU8,
          filename: currentDownloadName || 'image_240.jpg'
        };
      } catch (error) {
        console.error(error);
        alert('Fehler beim JPEG-Encode: ' + (error?.message || error));
        throw error;
      }
    }

    async function writeBle(characteristic, data) {
      await characteristic.writeValue(data);
    }

    async function waitFor(predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (performance.now() < deadline) {
        if (predicate()) return true;
        await delay(50);
      }
      return predicate();
    }

    async function sendViaBle() {
      if (!bleSupported) {
        alert('WebBluetooth wird von diesem Browser nicht unterstützt. Bitte Chrome, Edge oder Android Chrome verwenden.');
        return;
      }
      if (bleSending) return;
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        return;
      }

      let device = null;
      let server = null;
      let control = null;
      let chunk = null;
      let notifyHandler = null;
      let startConfirmed = false;
      let remoteError = null;
      let remoteDone = false;

      try {
        bleSending = true;
        updateActionButtons();
        setBleStatus('Bild wird vorbereitet …');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForBle(filename);

        setBleStatus('Bitte Brosche auswählen …');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Brosche' }],
          optionalServices: [BLE_UUIDS.service]
        });
        device.addEventListener('gattserverdisconnected', () => {
          if (!remoteDone) {
            setBleStatus('BLE-Verbindung getrennt');
          }
        });

        setBleStatus('Verbindung wird hergestellt …');
        server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_UUIDS.service);
        control = await service.getCharacteristic(BLE_UUIDS.control);
        chunk = await service.getCharacteristic(BLE_UUIDS.chunk);
        await control.startNotifications();

        notifyHandler = (event) => {
          const value = event.target.value;
          const text = textDecoder.decode(value);
          if (!text) return;
          console.log('[BLE] Status', text);
          if (text.startsWith('OK:START')) {
            startConfirmed = true;
            setBleStatus(`Übertragung gestartet (${sanitizedName})`);
          } else if (text.startsWith('OK:PROG:')) {
            const parts = text.split(':');
            if (parts.length >= 4) {
              const received = Number(parts[2]) || 0;
              const total = Number(parts[3]) || 0;
              const pct = total ? Math.min(100, Math.round((received / total) * 100)) : 0;
              setBleStatus(`Brosche empfängt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          } else if (text.startsWith('OK:END')) {
            remoteDone = true;
            setBleStatus('Übertragung abgeschlossen.');
          } else if (text.startsWith('ERR:')) {
            remoteError = text.substring(4) || 'Unbekannter Fehler';
            setBleStatus(`Fehler vom Gerät: ${remoteError}`);
          }
        };
        control.addEventListener('characteristicvaluechanged', notifyHandler);

        const startPayload = `START:${bytes.length}:${sanitizedName}`;
        await writeBle(control, textEncoder.encode(startPayload));
        const startOk = await waitFor(() => startConfirmed || remoteError, 2000);
        if (remoteError) throw new Error(remoteError);
        if (!startOk) {
          throw new Error('Keine Rückmeldung vom Gerät (BLE-Modus aktiv?).');
        }

        setBleStatus('Sende Bilddaten …');
        const chunkSize = 20;
        for (let offset = 0; offset < bytes.length; offset += chunkSize) {
          const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
          await writeBle(chunk, slice);
          if (remoteError) break;
          if ((offset / chunkSize) % 24 === 0) {
            const sent = offset + slice.length;
            const percent = Math.min(100, Math.round((sent / bytes.length) * 100));
            setBleStatus(`Sende ${percent}% (${humanReadableSize(sent)} / ${humanReadableSize(bytes.length)})`);
          }
          await delay(4);
        }

        if (remoteError) throw new Error(remoteError);

        await writeBle(control, textEncoder.encode('END'));
        setBleStatus('Übertragung gesendet, warte auf Bestätigung …');
        await waitFor(() => remoteDone || remoteError, 3000);
        if (remoteError) throw new Error(remoteError);
        if (!remoteDone) {
          setBleStatus('Bild übertragen – Brosche sollte das Bild anzeigen.');
        }
      } catch (error) {
        console.error(error);
        const message = error?.message || error?.toString() || 'Unbekannter Fehler';
        setBleStatus(`Fehler: ${message}`);
        alert('Fehler beim BLE-Senden: ' + message);
      } finally {
        try {
          if (control && notifyHandler) {
            control.removeEventListener('characteristicvaluechanged', notifyHandler);
            await control.stopNotifications();
          }
        } catch (_) { /* noop */ }
        try {
          if (server?.connected) {
            server.disconnect();
          }
        } catch (_) { /* noop */ }
        bleSending = false;
        updateActionButtons();
      }
    }

    function hasFilePayload(evt) {
      const dt = evt?.dataTransfer;
      if (!dt) return false;
      if (dt.types) {
        if (typeof dt.types.includes === 'function' && dt.types.includes('Files')) return true;
        if (typeof dt.types.contains === 'function' && dt.types.contains('Files')) return true;
      }
      return !!(dt.files && dt.files.length);
    }

    function extractFileFromDataTransfer(dt) {
      if (!dt) return null;
      if (dt.files && dt.files.length) return dt.files[0];
      if (dt.items) {
        for (const item of dt.items) {
          if (item.kind === 'file') {
            const file = item.getAsFile();
            if (file) return file;
          }
        }
      }
      return null;
    }

    function buildDownloadName(originalName) {
      const raw = typeof originalName === 'string' ? originalName : '';
      const normalized = raw.split(/[\\/]/).pop() || '';
      const idx = normalized.lastIndexOf('.');
      const base = idx > 0 ? normalized.slice(0, idx) : (normalized || 'image');
      return `${base}_240.jpg`;
    }

    function setDropActive(active) {
      document.body.classList.toggle('drop-active', active);
    }

    async function initMozIfNeeded() {
      if (moz) {
        mozReady = true;
        return true;
      }
      try {
        moz = await moduleFactory(); // lädt automatisch mozjpeg_enc.wasm
        console.log('MozJPEG (WASM) bereit.');
        mozReady = true;
        updateActionButtons();
        return true;
      } catch (err) {
        console.error(err);
        alert('Konnte MozJPEG-WASM nicht laden. Prüfe Internetverbindung oder nutze lokale Dateien in ./mozjpeg/');
        return false;
      }
    }

    async function setBitmapFromFile(file) {
      if (!file) return;
      if (file.type && !file.type.startsWith('image/')) {
        alert('Bitte eine Bilddatei auswählen oder ablegen.');
        return;
      }
      try {
        currentBitmap = await loadImageBitmap(file);
      } catch (err) {
        console.error(err);
        alert('Konnte die Bilddatei nicht laden. Versuche es bitte mit einer anderen Datei.');
        return;
      }
      const displayName = file.name ? file.name.split(/[\\/]/).pop() : '';
      currentDownloadName = buildDownloadName(displayName);
      resetCoverPan();
      drawScaled(currentBitmap);
      updateCanvasCursor();
      fileInput.value = '';
      await initMozIfNeeded();
      updateActionButtons();
      if (!bleSending) {
        setBleStatus('');
      }
    }

    // JPEG header scan to verify non-progressive:
    // Baseline SOF0 marker = 0xFFC0, Progressive SOF2 = 0xFFC2
    function isProgressiveJPEG(u8) {
      for (let i = 0; i < u8.length - 1; i++) {
        if (u8[i] === 0xFF) {
          const code = u8[i + 1];
          if (code === 0xC2) return true;   // SOF2
          if (code === 0xDA) break;         // SOS reached -> stop scanning
        }
      }
      return false;
    }

    function clearCanvas() {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, cv.width, cv.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, cv.width, cv.height);
      ctx.restore();
    }

    function resetCoverPan() {
      coverPan.x = 0;
      coverPan.y = 0;
    }

    async function loadImageBitmap(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      await img.decode();
      const bmp = await createImageBitmap(img);
      URL.revokeObjectURL(url);
      return bmp;
    }

    function clampCoverPanValues(bmp, x, y) {
      if (!bmp) return { x: 0, y: 0 };
      const T = 240;
      const s = Math.max(T / bmp.width, T / bmp.height);
      const w = bmp.width * s;
      const h = bmp.height * s;
      const maxPanX = Math.max(0, (w - T) / 2);
      const maxPanY = Math.max(0, (h - T) / 2);
      return {
        x: Math.max(-maxPanX, Math.min(maxPanX, x)),
        y: Math.max(-maxPanY, Math.min(maxPanY, y))
      };
    }

    function updateCanvasCursor() {
      if (currentBitmap && modeSel.value === 'cover') {
        cv.style.cursor = isDragging ? 'grabbing' : 'grab';
      } else {
        cv.style.cursor = 'default';
      }
    }

    function drawScaled(bmp) {
      clearCanvas();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const T = 240, sw = bmp.width, sh = bmp.height;
      if (modeSel.value === 'cover') {
        const s = Math.max(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const clamped = clampCoverPanValues(bmp, coverPan.x, coverPan.y);
        coverPan.x = clamped.x;
        coverPan.y = clamped.y;
        const dx = (T - w) / 2 + coverPan.x;
        const dy = (T - h) / 2 + coverPan.y;
        ctx.drawImage(bmp, dx, dy, w, h);
      } else {
        const s = Math.min(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const dx = (T - w) / 2, dy = (T - h) / 2;
        ctx.drawImage(bmp, dx, dy, w, h);
      }
    }

    document.documentElement.addEventListener('dragenter', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (dropDepth++ === 0) {
        setDropActive(true);
      }
    });

    document.documentElement.addEventListener('dragover', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'copy';
      }
    });

    document.documentElement.addEventListener('dragleave', () => {
      if (dropDepth > 0) dropDepth--;
      if (dropDepth === 0) {
        setDropActive(false);
      }
    });

    document.documentElement.addEventListener('drop', async (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      dropDepth = 0;
      setDropActive(false);
      const file = extractFileFromDataTransfer(e.dataTransfer);
      await setBitmapFromFile(file);
    });

    window.addEventListener('blur', () => {
      dropDepth = 0;
      setDropActive(false);
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      await setBitmapFromFile(file);
    });

    modeSel.addEventListener('change', () => {
      if (isDragging) {
        isDragging = false;
      }
      updateCanvasCursor();
      if (currentBitmap) drawScaled(currentBitmap);
    });

    cv.addEventListener('pointerdown', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      e.preventDefault();
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      panStart = { x: coverPan.x, y: coverPan.y };
      try {
        cv.setPointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    });

    cv.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      const nextPan = clampCoverPanValues(currentBitmap, panStart.x + dx, panStart.y + dy);
      coverPan.x = nextPan.x;
      coverPan.y = nextPan.y;
      drawScaled(currentBitmap);
    });

    function endDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      try {
        cv.releasePointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    }

    cv.addEventListener('pointerup', endDrag);
    cv.addEventListener('pointercancel', endDrag);

    btnSave.addEventListener('click', async () => {
      if (bleSending) return;
      btnSave.disabled = true;
      try {
        const { bytes, filename } = await encodeCurrentImage();
        const blob = new Blob([bytes], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename || 'image_240.jpg';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
      } finally {
        updateActionButtons();
      }
    });

    btnBle.addEventListener('click', sendViaBle);

    if (!secureContext) {
      btnBle.title = 'WebBluetooth benötigt HTTPS oder localhost.';
      setBleStatus('WebBluetooth benötigt eine sichere Herkunft. Bitte die Seite über https:// oder http://localhost ausliefern (z. B. "python -m http.server" nutzen) und dann erneut versuchen.');
    } else if (!bleAvailable) {
      btnBle.title = 'WebBluetooth wird von diesem Browser nicht freigegeben.';
      setBleStatus('WebBluetooth wird von diesem Browser/Profil nicht unterstützt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge.');
    }

    updateActionButtons();
  </script>
</body>
</html>

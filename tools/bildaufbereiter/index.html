<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bilderaufbereiter für die LCD-Brosche</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 880px; margin: 2rem auto; padding: 0 1rem; background: #f8f9fb; color: #1f252d; }
    header { margin-bottom: 1rem; display: flex; align-items: flex-start; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap; }
    .header__text { flex: 1 1 320px; min-width: 0; }
    .header__logo { display: block; flex: 0 0 auto; width: 160px; margin-left: auto; order: 0; }
    .header__logo img { display: block; width: 100%; max-width: 100%; height: auto; }
    @media (max-width: 680px) {
      header { flex-direction: column; align-items: center; text-align: center; }
      .header__text { flex: 1 1 auto; }
      .header__logo { order: -1; margin-left: 0; margin-bottom: .75rem; }
    }
    h1 { font-size: clamp(1.4rem, 2.5vw, 2rem); margin: 0 0 .25rem; }
    .muted { opacity: .75; }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; margin: .75rem 0; }
    .preview { position: relative; display: block; width: 358.2857142857px; height: 350.0571428571px; margin: 2.5rem auto 0; }
    .preview__viewport { position: absolute; top: 43.7142857143px; left: 55.0285714286px; width: 240px; height: 240px; border-radius: 50%; overflow: hidden; border: 1px solid #c9c9c9; box-shadow: 0 1px 8px rgba(0,0,0,.08); background: #fff; }
    .preview__viewport::after { content: ""; position: absolute; inset: 0; border-radius: 50%; pointer-events: none; box-shadow: inset 0 0 0 1px rgba(0,0,0,.12); }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: default; }
    .preview__mask { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; object-fit: cover; }
    button, select, input[type="number"], input[type="file"] { padding: .55rem .8rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: #ffffff; color: inherit; }
    button[disabled] { opacity: .5; }
    .actions { margin: 1.5rem 0 0; }
    footer { margin-top: 2rem; font-size: .9rem; }
    code { background: rgba(127,127,127,.15); padding: .1rem .3rem; border-radius: .3rem; }
    .drop-overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; padding: 2rem; color: #1f4d8f; font-weight: 600; font-size: clamp(1.1rem, 2.5vw, 1.6rem); background: rgba(74,144,226,.14); border: 2px dashed rgba(74,144,226,.6); pointer-events: none; opacity: 0; transform: scale(1.02); transition: opacity .2s ease, transform .2s ease; z-index: 999; }
    body.drop-active .drop-overlay { opacity: 1; transform: scale(1); }
    body.drop-active .preview__viewport { border-color: #4a90e2; box-shadow: 0 0 0 4px rgba(74,144,226,.25); }
    .drop-hint { margin: -.25rem 0 0; font-size: .9rem; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
    .file-picker { display: flex; align-items: center; gap: .6rem; flex-wrap: wrap; }
    .file-picker__button { display: inline-flex; align-items: center; justify-content: center; padding: .55rem .9rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: canvas; cursor: pointer; font-weight: 400; }
    .file-picker__button:focus-visible { outline: 2px solid #4a90e2; outline-offset: 2px; }
    .version-tag { font-weight: 600; font-size: .82rem; text-transform: uppercase; letter-spacing: .08em; margin-top: .4rem; color: #4a90e2; }
  </style>
</head>
<body>
  <div class="drop-overlay" aria-hidden="true">Bilddatei hier ablegen, um sie zu laden</div>
  <header>
    <div class="header__text">
      <h1>Bilderaufbereiter für die LCD-Brosche</h1>
      <p class="muted">Mit dieser Anwendung kannst du deine Bilder so vorbereiten, dass sie perfekt auf der Brosche angezeigt werden. Du kannst sie anschliessend per Bluetooth, USB oder über eine SD-Karte auf die Brosche übertragen.</p>
      <p class="muted version-tag" id="tool-version"></p>
    </div>
    <a class="header__logo" href="https://www.teil3.ch" target="_blank" rel="noopener">
      <img src="teil3_logo.svg" alt="Teil3 Logo" width="160" height="95" />
    </a>
  </header>

  <div class="row">
    <div class="file-picker">
      <label class="file-picker__button" for="file">Bild auswählen…</label>
      <input id="file" type="file" accept="image/*" class="visually-hidden" />
    </div>
    <label>Zuschnitt:
      <select id="mode">
        <option value="cover">Zentriert zuschneiden (füllend)</option>
        <option value="contain">Einpassen (weiß auffüllen)</option>
      </select>
    </label>
    <label>Qualität:
      <input id="quality" type="number" min="10" max="100" value="92" style="width:5rem"> %
    </label>
  </div>
  <p class="muted drop-hint">Tipp: Ziehe eine Bilddatei irgendwo auf diese Seite – sie wird automatisch geladen.</p>

  <div class="preview">
    <div class="preview__viewport">
      <canvas id="cv" width="240" height="240"></canvas>
    </div>
    <img class="preview__mask" src="./LCD-Brosche-maske.png" alt="Maske der LCD-Brosche" />
  </div>

  <div class="actions">
    <button id="save" disabled>Als JPEG speichern</button>
    <button id="send-usb" disabled>Über USB senden</button>
    <button id="send-ble" disabled>Per Bluetooth senden</button>
    <p id="usb-status" class="muted" aria-live="polite"></p>
    <p id="ble-status" class="muted" aria-live="polite"></p>
    <p class="muted" id="ble-hint">Hinweis: Auf der Brosche den BLE-Empfangsmodus aktivieren (BTN2 in der Diashow App mehrmals lang drücken, bis "Bluetooth Modus" angezeigt wird).</p>
  </div>

  <script type="module">
    // --- Import der MozJPEG-WASM-Codec-Factory (jSquash, auf UNPKG gehostet) ---
    // Dokumentation/Quelle: https://github.com/jamsinclair/jSquash (encode API) –
    // und Typdefinitionen der Optionen (mozjpeg_enc.d.ts)
    const moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;
    const TOOL_VERSION = 'USB Debug build 2025-02-21 00:14Z (no start ack)';
    //const moduleFactory = (await import('./mozjpeg/mozjpeg_enc.js?module')).default;

    // Fallback: Wenn du die WASM/JS lokal ausliefern willst, lege sie in ./mozjpeg/ ab
    // und ersetze die URL oben durch: './mozjpeg/mozjpeg_enc.js'
    // (Achte darauf, dass mozjpeg_enc.wasm im selben Ordner liegt.)

    const fileInput = document.getElementById('file');
    const modeSel   = document.getElementById('mode');
    const qInput    = document.getElementById('quality');
    const btnSave   = document.getElementById('save');
    const btnUsb    = document.getElementById('send-usb');
    const btnBle    = document.getElementById('send-ble');
    const versionLabel = document.getElementById('tool-version');
    const usbStatus = document.getElementById('usb-status');
    const bleStatus = document.getElementById('ble-status');
    const cv        = document.getElementById('cv');
    const ctx       = cv.getContext('2d', { willReadFrequently: true });
    const BLE_UUIDS = {
      service: '12345678-1234-1234-1234-1234567890ab',
      chunk:   'abcd0001-1234-1234-1234-1234567890ab',
      control: 'abcd0002-1234-1234-1234-1234567890ab'
    };
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    let currentBitmap = null;
    let moz = null;
    let mozReady = false;
    let coverPan = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };
    let dropDepth = 0;
    let currentDownloadName = 'image_240.jpg';
    let bleSending = false;
    let usbSending = false;
    const usbDebugLog = [];

    if (versionLabel) {
      versionLabel.textContent = TOOL_VERSION;
    }

    const secureContextHosts = new Set(['localhost', '127.0.0.1', '::1']);
    const secureContext = window.isSecureContext || secureContextHosts.has(location.hostname);
    const bleAvailable = 'bluetooth' in navigator;
    const bleSupported = secureContext && bleAvailable;
    const serialAvailable = 'serial' in navigator;
    const usbSupported = secureContext && serialAvailable;

    function setUsbStatus(text) {
      if (!usbStatus) return;
      usbStatus.textContent = text || '';
    }

    function usbLog(direction, message) {
      const entry = `${direction} ${message}`;
      if (usbDebugLog.length >= 80) {
        usbDebugLog.shift();
      }
      usbDebugLog.push(entry);
      console.debug('[USB LOG]', entry);
    }

    function usbLogSnapshot() {
      return usbDebugLog.slice(-12).join('\n');
    }

    function alertUsbError(message) {
      const log = usbLogSnapshot();
      const detail = log ? `\n\nLetzte USB-Meldungen:\n${log}` : '';
      console.error('USB ERROR:', message, { log: usbDebugLog.slice() });
      alert(`${message}${detail}`);
    }

    function setBleStatus(text) {
      if (!bleStatus) return;
      bleStatus.textContent = text || '';
    }

    function updateActionButtons() {
      const ready = !!currentBitmap && mozReady;
      const busy = bleSending || usbSending;
      if (btnSave) btnSave.disabled = !ready || busy;
      if (btnUsb) btnUsb.disabled = !ready || !usbSupported || busy;
      if (btnBle) btnBle.disabled = !ready || !bleSupported || busy;
    }

    function sanitizeFilenameForTransfer(name) {
      const fallback = 'ble_image.jpg';
      if (!name) return fallback;
      let base = name.split(/[\\/]/).pop() || fallback;
      base = base.toLowerCase();
      let out = '';
      for (const ch of base) {
        if ((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch === '-' || ch === '_' || ch === '.') {
          out += ch;
        } else if (ch === ' ') {
          out += '_';
        }
        if (out.length >= 60) break;
      }
      if (!out) out = fallback;
      if (out.startsWith('.')) out = out.substring(1) || fallback;
      if (!out.endsWith('.jpg') && !out.endsWith('.jpeg')) {
        out += '.jpg';
      }
      if (out.length > 60) {
        const idx = out.lastIndexOf('.');
        const ext = idx >= 0 ? out.slice(idx) : '.jpg';
        const stem = idx >= 0 ? out.slice(0, idx) : out;
        out = stem.slice(0, Math.max(1, 60 - ext.length)) + ext;
      }
      return out;
    }

    function humanReadableSize(bytes) {
      if (!Number.isFinite(bytes)) return '0 B';
      if (bytes < 1024) return `${bytes} B`;
      const kb = bytes / 1024;
      const rounded = Math.round(kb * 10) / 10;
      return `${rounded.toFixed(rounded % 1 === 0 ? 0 : 1)} KB`;
    }

    async function encodeCurrentImage() {
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        throw new Error('Kein Bild geladen');
      }
      const ready = await initMozIfNeeded();
      if (!ready || !moz) {
        throw new Error('JPEG-Codec nicht verfügbar');
      }
      const { data } = ctx.getImageData(0, 0, cv.width, cv.height);
      const quality = Math.min(100, Math.max(10, parseInt(qInput.value, 10) || 92));
      const opts = {
        quality,
        baseline: true,
        progressive: false,
        arithmetic: false,
        optimize_coding: true,
        smoothing: 0,
        color_space: 3,
        quant_table: 3,
        trellis_multipass: false,
        trellis_opt_zero: false,
        trellis_opt_table: false,
        trellis_loops: 1,
        auto_subsample: false,
        chroma_subsample: 2,
        separate_chroma_quality: false,
        chroma_quality: quality
      };

      try {
        const jpegU8 = moz.encode(data, 240, 240, opts);
        if (isProgressiveJPEG(jpegU8)) {
          alert('Warnung: Der erzeugte JPEG scheint progressiv zu sein.');
        }
        return {
          bytes: jpegU8,
          filename: currentDownloadName || 'image_240.jpg'
        };
      } catch (error) {
        console.error(error);
        alert('Fehler beim JPEG-Encode: ' + (error?.message || error));
        throw error;
      }
    }

    async function writeBle(characteristic, data) {
      await characteristic.writeValue(data);
    }

    async function waitFor(predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (performance.now() < deadline) {
        if (predicate()) return true;
        await delay(50);
      }
      return predicate();
    }

    function createLineReader(reader) {
      let buffer = '';
      return {
        async readLine(timeoutMs) {
          const deadline = (typeof timeoutMs === 'number')
            ? performance.now() + timeoutMs
            : null;
          while (true) {
            const newlineIdx = buffer.indexOf('\n');
            if (newlineIdx >= 0) {
              const line = buffer.slice(0, newlineIdx);
              buffer = buffer.slice(newlineIdx + 1);
              return line.replace(/\r$/, '');
            }

            const readPromise = reader.read();
            let result;
            if (deadline !== null) {
              const remaining = deadline - performance.now();
              if (remaining <= 0) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
              result = await Promise.race([
                readPromise,
                delay(Math.max(remaining, 0)).then(() => ({ timeout: true })),
              ]);
              if (result?.timeout) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
            } else {
              result = await readPromise;
            }

            if (result.done) {
              if (buffer.length > 0) {
                const line = buffer;
                buffer = '';
                return line.replace(/\r$/, '');
              }
              throw new Error('Verbindung geschlossen');
            }
            if (result.value) {
              buffer += result.value;
            }
          }
        }
      };
    }

    async function waitForUsbLine(lineReader, predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (true) {
        const remaining = deadline - performance.now();
        if (remaining <= 0) {
          throw new Error('Timeout beim Warten auf Antwort des Geräts');
        }
        const line = (await lineReader.readLine(Math.max(remaining, 50))).trim();
        if (!line) continue;
        usbLog('<=', line);
        if (!line.startsWith('USB')) {
          continue;
        }
        const payload = line.slice(3).trimStart();
        if (payload.startsWith('ERR')) {
          const message = payload.substring(3).trim();
          throw new Error(message || 'Gerätefehler');
        }
        if (payload.startsWith('OK PROG')) {
          const parts = payload.split(/\s+/);
          if (parts.length >= 4) {
            const received = Number(parts[2]);
            const total = Number(parts[3]);
            if (Number.isFinite(received) && Number.isFinite(total) && total > 0) {
              const pct = Math.min(100, Math.round((received / total) * 100));
              setUsbStatus(`Gerät empfängt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          }
          continue;
        }
        if (payload.startsWith('OK MSG')) {
          const msg = payload.substring(6).trim();
          if (msg) setUsbStatus(msg);
          continue;
        }
        if (predicate(payload)) {
          return payload;
        }
      }
    }

    async function sendViaUsb() {
      if (!usbSupported) {
        alert('WebSerial wird von diesem Browser nicht unterstützt. Bitte Chrome oder Edge auf dem Desktop verwenden.');
        return;
      }
      if (usbSending || bleSending) return;
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        return;
      }

      usbDebugLog.length = 0;

      let port = null;
      let writer = null;
      let reader = null;
      let readableClosed = null;
      let lineReader = null;
      let transferCompleted = false;

      try {
        usbSending = true;
        updateActionButtons();
        setUsbStatus('Bild wird vorbereitet …');
        usbLog('<>', 'Beginne USB-Transfer');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);
        const totalSize = bytes.length;
        const totalLabel = humanReadableSize(totalSize);

        setUsbStatus('Seriellen Port auswählen …');
        port = await navigator.serial.requestPort();
        try {
          await port.open({ baudRate: 115200, dataBits: 8, stopBits: 1, parity: 'none', flowControl: 'none' });
        } catch (err) {
          usbLog('!!', `open failed: ${err?.message || err}`);
          throw err;
        }

        if (typeof port.setSignals === 'function') {
          try {
            await port.setSignals({ dataTerminalReady: true, requestToSend: true, break: false });
            usbLog('<>', 'setSignals DTR=1 RTS=1');
          } catch (err) {
            usbLog('<>', `setSignals failed: ${err?.message || err}`);
          }
        }

        await delay(400);

        if (!port.writable) {
          throw new Error('Port bietet keinen Schreibstream.');
        }
        if (!port.readable) {
          throw new Error('Port bietet keinen Lesestream.');
        }

        if (typeof TextDecoderStream === 'undefined') {
          throw new Error('TextDecoderStream wird nicht unterstützt. Bitte einen aktuellen Chromium-Browser verwenden.');
        }
        const decoder = new TextDecoderStream();
        readableClosed = port.readable.pipeTo(decoder.writable).catch(() => {});
        reader = decoder.readable.getReader();
        lineReader = createLineReader(reader);

        writer = port.writable.getWriter();

        // Optional: READY-Meldung ignorieren – START funktioniert auch ohne.

        const startLine = `START ${totalSize} ${sanitizedName}\n`;
        usbLog('->', startLine.trim());
        await writer.write(textEncoder.encode(startLine));

        let startAck = null;
        try {
          startAck = await waitForUsbLine(
            lineReader,
            (payload) => payload.startsWith('OK START') || payload.startsWith('OK READY'),
            6000
          );
        } catch (err) {
          usbLog('!!', `Keine START-Bestätigung innerhalb 6s: ${err?.message || err}`);
        }
        if (startAck && startAck.startsWith('OK READY')) {
          usbLog('<>', 'READY kam nach START; warte optional auf OK START');
          try {
            const follow = await waitForUsbLine(
              lineReader,
              (payload) => payload.startsWith('OK START'),
              4000
            );
            startAck = follow;
          } catch (err) {
            usbLog('!!', `Kein OK START nach READY: ${err?.message || err}`);
          }
        }

        if (startAck && startAck.startsWith('OK START')) {
          let deviceFilename = sanitizedName;
          const startParts = startAck.split(/\s+/);
          if (startParts.length >= 3) {
            deviceFilename = startParts[2];
          }
          setUsbStatus(`Übertragung gestartet (${deviceFilename})`);
          usbLog('<>', `Transfer bestätigt: ${deviceFilename}`);
        } else {
          setUsbStatus('Starte Übertragung (keine Bestätigung erhalten – sende trotzdem)…');
          usbLog('!!', 'Sende Daten ohne Start-Bestätigung');
        }

        const chunkSize = 1024;
        let sent = 0;
        setUsbStatus(`Sende 0% (0 / ${totalLabel})`);

        for (let offset = 0; offset < totalSize; offset += chunkSize) {
          const slice = bytes.subarray(offset, Math.min(offset + chunkSize, totalSize));
          if (offset === 0 || (offset % (chunkSize * 32) === 0)) {
            usbLog('->', `DATA ${offset}/${totalSize}`);
          }
          await writer.write(slice);
          sent += slice.length;

          if (sent === totalSize || sent <= chunkSize || (sent % (chunkSize * 12)) === 0) {
            const pct = Math.min(100, Math.round((sent / totalSize) * 100));
            setUsbStatus(`Sende ${pct}% (${humanReadableSize(sent)} / ${totalLabel})`);
          }
          await delay(3);
        }

        usbLog('->', 'END');
        await writer.write(textEncoder.encode('END\n'));

        const endPredicate = (payload) => {
          if (payload.startsWith('OK END')) {
            return true;
          }
          if (payload.startsWith('OK PROG')) {
            const parts = payload.split(/\s+/);
            if (parts.length >= 4) {
              const received = Number(parts[2]);
              const total = Number(parts[3]);
              if (Number.isFinite(received) && Number.isFinite(total) && total > 0 && received >= total) {
                return true;
              }
            }
          }
          return false;
        };

        const endAck = await waitForUsbLine(lineReader, endPredicate, 14000);
        if (endAck.startsWith('OK PROG')) {
          setUsbStatus('Übertragung abgeschlossen ✅ (Bestätigung über Fortschrittsmeldung)');
        } else {
          const endParts = endAck.split(/\s+/);
          if (endParts.length >= 3) {
            setUsbStatus(`Übertragung abgeschlossen ✅ (${endParts[2]})`);
          } else {
            setUsbStatus('Übertragung abgeschlossen ✅');
          }
        }
        transferCompleted = true;
        } catch (error) {
          console.error(error);
          const name = error?.name;
          if (name === 'NotFoundError') {
            setUsbStatus('USB-Senden abgebrochen – kein Port ausgewählt.');
            alertUsbError('USB-Senden abgebrochen – kein Port ausgewählt.');
          } else if (name === 'AbortError') {
            setUsbStatus('USB-Senden abgebrochen.');
            alertUsbError('USB-Senden abgebrochen.');
          } else if (name === 'NetworkError' || /device has been lost/i.test(error?.message || '')) {
            if (transferCompleted) {
              setUsbStatus('Übertragung abgeschlossen ✅ (Gerät hat den Port getrennt).');
            } else {
              setUsbStatus('USB-Verbindung verloren – bitte Brosche neu verbinden und Transfer-Modus erneut aktivieren.');
              alertUsbError('USB-Verbindung verloren. Bitte den ESP32 neu verbinden, Transfer-Modus (BTN2 lang) aktivieren und erneut senden.');
            }
          } else if (/timeout beim warten/i.test(error?.message || '')) {
            setUsbStatus('Timeout – keine Antwort vom Gerät. Ist der Transfer-Modus aktiv (BTN2 lang in der Diashow)?');
            alertUsbError('Keine Antwort vom Gerät erhalten. Bitte sicherstellen, dass die Brosche im Transfer-Modus ist (BTN2 lang halten, bis "Transfer" angezeigt wird) und erneut versuchen.');
          } else {
            const message = error?.message || error?.toString() || 'Unbekannter Fehler';
            setUsbStatus(`Fehler: ${message}`);
            alertUsbError('Fehler beim USB-Senden: ' + message);
          }
      } finally {
        try {
          if (writer) {
            usbLog('<>', 'release writer');
            await writer.releaseLock();
          }
        } catch (_) { /* ignore */ }
        try {
          if (reader) {
            usbLog('<>', 'cancel reader');
            await reader.cancel();
          }
        } catch (_) { /* ignore */ }
        try {
          if (readableClosed) {
            usbLog('<>', 'await readable close');
            await readableClosed.catch(() => {});
          }
        } catch (_) { /* ignore */ }
        try {
          if (port) {
            usbLog('<>', 'close port');
            await port.close();
          }
        } catch (_) { /* ignore */ }
        usbSending = false;
        updateActionButtons();
      }
    }

    async function sendViaBle() {
      if (!bleSupported) {
        alert('WebBluetooth wird von diesem Browser nicht unterstützt. Bitte Chrome, Edge oder Android Chrome verwenden.');
        return;
      }
      if (bleSending || usbSending) return;
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        return;
      }

      let device = null;
      let server = null;
      let control = null;
      let chunk = null;
      let notifyHandler = null;
      let startConfirmed = false;
      let remoteError = null;
      let remoteDone = false;

      try {
        bleSending = true;
        updateActionButtons();
        setBleStatus('Bild wird vorbereitet …');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);

        setBleStatus('Bitte Brosche auswählen …');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Brosche' }],
          optionalServices: [BLE_UUIDS.service]
        });
        device.addEventListener('gattserverdisconnected', () => {
          if (!remoteDone) {
            setBleStatus('BLE-Verbindung getrennt');
          }
        });

        setBleStatus('Verbindung wird hergestellt …');
        server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_UUIDS.service);
        control = await service.getCharacteristic(BLE_UUIDS.control);
        chunk = await service.getCharacteristic(BLE_UUIDS.chunk);

        console.debug('BLE control props', control.properties);
        console.debug('BLE chunk props', chunk.properties);

        setBleStatus('Aktiviere Statusmeldungen …');
        try {
          await control.startNotifications();
        } catch (err) {
          throw new Error('startNotifications fehlgeschlagen: ' + (err?.message || err));
        }

        notifyHandler = (event) => {
          const value = event.target.value;
          const text = textDecoder.decode(value);
          if (!text) return;
          console.log('[BLE] Status', text);
          if (text.startsWith('OK:START')) {
            startConfirmed = true;
            setBleStatus(`Übertragung gestartet (${sanitizedName})`);
          } else if (text.startsWith('OK:PROG:')) {
            const parts = text.split(':');
            if (parts.length >= 4) {
              const received = Number(parts[2]) || 0;
              const total = Number(parts[3]) || 0;
              const pct = total ? Math.min(100, Math.round((received / total) * 100)) : 0;
              setBleStatus(`Brosche empfängt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          } else if (text.startsWith('OK:END')) {
            remoteDone = true;
            setBleStatus('Übertragung abgeschlossen.');
          } else if (text.startsWith('ERR:')) {
            remoteError = text.substring(4) || 'Unbekannter Fehler';
            setBleStatus(`Fehler vom Gerät: ${remoteError}`);
          }
        };
        control.addEventListener('characteristicvaluechanged', notifyHandler);

        const startPayload = `START:${bytes.length}:${sanitizedName}`;
        try {
          await writeBle(control, textEncoder.encode(startPayload));
        } catch (err) {
          throw new Error('START schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        const startOk = await waitFor(() => startConfirmed || remoteError, 2000);
        if (remoteError) throw new Error(remoteError);
        if (!startOk) {
          throw new Error('Keine Rückmeldung vom Gerät (BLE-Modus aktiv?).');
        }

        setBleStatus('Sende Bilddaten …');
        const chunkSize = 20;
        for (let offset = 0; offset < bytes.length; offset += chunkSize) {
          const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
          try {
            await writeBle(chunk, slice);
          } catch (err) {
            throw new Error(`Chunk @${offset} (${slice.length} B) fehlgeschlagen: ${err?.message || err}`);
          }
          if (remoteError) break;
          if ((offset / chunkSize) % 24 === 0) {
            const sent = offset + slice.length;
            const percent = Math.min(100, Math.round((sent / bytes.length) * 100));
            setBleStatus(`Sende ${percent}% (${humanReadableSize(sent)} / ${humanReadableSize(bytes.length)})`);
          }
          await delay(4);
        }

        if (remoteError) throw new Error(remoteError);

        try {
          await writeBle(control, textEncoder.encode('END'));
        } catch (err) {
          throw new Error('END schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        setBleStatus('Übertragung gesendet, warte auf Bestätigung …');
        await waitFor(() => remoteDone || remoteError, 3000);
        if (remoteError) throw new Error(remoteError);
        if (!remoteDone) {
          setBleStatus('Bild übertragen – Brosche sollte das Bild anzeigen.');
        }
      } catch (error) {
        console.error(error);
        const message = error?.message || error?.toString() || 'Unbekannter Fehler';
        setBleStatus(`Fehler: ${message}`);
        alert('Fehler beim BLE-Senden: ' + message);
      } finally {
        try {
          if (control && notifyHandler) {
            control.removeEventListener('characteristicvaluechanged', notifyHandler);
            await control.stopNotifications();
          }
        } catch (_) { /* noop */ }
        try {
          if (server?.connected) {
            server.disconnect();
          }
        } catch (_) { /* noop */ }
        bleSending = false;
        updateActionButtons();
      }
    }

    function hasFilePayload(evt) {
      const dt = evt?.dataTransfer;
      if (!dt) return false;
      if (dt.types) {
        if (typeof dt.types.includes === 'function' && dt.types.includes('Files')) return true;
        if (typeof dt.types.contains === 'function' && dt.types.contains('Files')) return true;
      }
      return !!(dt.files && dt.files.length);
    }

    function extractFileFromDataTransfer(dt) {
      if (!dt) return null;
      if (dt.files && dt.files.length) return dt.files[0];
      if (dt.items) {
        for (const item of dt.items) {
          if (item.kind === 'file') {
            const file = item.getAsFile();
            if (file) return file;
          }
        }
      }
      return null;
    }

    function buildDownloadName(originalName) {
      const raw = typeof originalName === 'string' ? originalName : '';
      const normalized = raw.split(/[\\/]/).pop() || '';
      const idx = normalized.lastIndexOf('.');
      const base = idx > 0 ? normalized.slice(0, idx) : (normalized || 'image');
      return `${base}_240.jpg`;
    }

    function setDropActive(active) {
      document.body.classList.toggle('drop-active', active);
    }

    async function initMozIfNeeded() {
      if (moz) {
        mozReady = true;
        return true;
      }
      try {
        moz = await moduleFactory(); // lädt automatisch mozjpeg_enc.wasm
        console.log('MozJPEG (WASM) bereit.');
        mozReady = true;
        updateActionButtons();
        return true;
      } catch (err) {
        console.error(err);
        alert('Konnte MozJPEG-WASM nicht laden. Prüfe Internetverbindung oder nutze lokale Dateien in ./mozjpeg/');
        return false;
      }
    }

    async function setBitmapFromFile(file) {
      if (!file) return;
      if (file.type && !file.type.startsWith('image/')) {
        alert('Bitte eine Bilddatei auswählen oder ablegen.');
        return;
      }
      try {
        currentBitmap = await loadImageBitmap(file);
      } catch (err) {
        console.error(err);
        alert('Konnte die Bilddatei nicht laden. Versuche es bitte mit einer anderen Datei.');
        return;
      }
      const displayName = file.name ? file.name.split(/[\\/]/).pop() : '';
      currentDownloadName = buildDownloadName(displayName);
      resetCoverPan();
      drawScaled(currentBitmap);
      updateCanvasCursor();
      fileInput.value = '';
      await initMozIfNeeded();
      updateActionButtons();
      if (!bleSending) {
        setBleStatus('');
      }
      if (!usbSending) {
        setUsbStatus('');
      }
    }

    // JPEG header scan to verify non-progressive:
    // Baseline SOF0 marker = 0xFFC0, Progressive SOF2 = 0xFFC2
    function isProgressiveJPEG(u8) {
      for (let i = 0; i < u8.length - 1; i++) {
        if (u8[i] === 0xFF) {
          const code = u8[i + 1];
          if (code === 0xC2) return true;   // SOF2
          if (code === 0xDA) break;         // SOS reached -> stop scanning
        }
      }
      return false;
    }

    function clearCanvas() {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, cv.width, cv.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, cv.width, cv.height);
      ctx.restore();
    }

    function resetCoverPan() {
      coverPan.x = 0;
      coverPan.y = 0;
    }

    async function loadImageBitmap(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      await img.decode();
      const bmp = await createImageBitmap(img);
      URL.revokeObjectURL(url);
      return bmp;
    }

    function clampCoverPanValues(bmp, x, y) {
      if (!bmp) return { x: 0, y: 0 };
      const T = 240;
      const s = Math.max(T / bmp.width, T / bmp.height);
      const w = bmp.width * s;
      const h = bmp.height * s;
      const maxPanX = Math.max(0, (w - T) / 2);
      const maxPanY = Math.max(0, (h - T) / 2);
      return {
        x: Math.max(-maxPanX, Math.min(maxPanX, x)),
        y: Math.max(-maxPanY, Math.min(maxPanY, y))
      };
    }

    function updateCanvasCursor() {
      if (currentBitmap && modeSel.value === 'cover') {
        cv.style.cursor = isDragging ? 'grabbing' : 'grab';
      } else {
        cv.style.cursor = 'default';
      }
    }

    function drawScaled(bmp) {
      clearCanvas();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const T = 240, sw = bmp.width, sh = bmp.height;
      if (modeSel.value === 'cover') {
        const s = Math.max(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const clamped = clampCoverPanValues(bmp, coverPan.x, coverPan.y);
        coverPan.x = clamped.x;
        coverPan.y = clamped.y;
        const dx = (T - w) / 2 + coverPan.x;
        const dy = (T - h) / 2 + coverPan.y;
        ctx.drawImage(bmp, dx, dy, w, h);
      } else {
        const s = Math.min(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const dx = (T - w) / 2, dy = (T - h) / 2;
        ctx.drawImage(bmp, dx, dy, w, h);
      }
    }

    document.documentElement.addEventListener('dragenter', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (dropDepth++ === 0) {
        setDropActive(true);
      }
    });

    document.documentElement.addEventListener('dragover', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'copy';
      }
    });

    document.documentElement.addEventListener('dragleave', () => {
      if (dropDepth > 0) dropDepth--;
      if (dropDepth === 0) {
        setDropActive(false);
      }
    });

    document.documentElement.addEventListener('drop', async (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      dropDepth = 0;
      setDropActive(false);
      const file = extractFileFromDataTransfer(e.dataTransfer);
      await setBitmapFromFile(file);
    });

    window.addEventListener('blur', () => {
      dropDepth = 0;
      setDropActive(false);
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      await setBitmapFromFile(file);
    });

    modeSel.addEventListener('change', () => {
      if (isDragging) {
        isDragging = false;
      }
      updateCanvasCursor();
      if (currentBitmap) drawScaled(currentBitmap);
    });

    cv.addEventListener('pointerdown', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      e.preventDefault();
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      panStart = { x: coverPan.x, y: coverPan.y };
      try {
        cv.setPointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    });

    cv.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      const nextPan = clampCoverPanValues(currentBitmap, panStart.x + dx, panStart.y + dy);
      coverPan.x = nextPan.x;
      coverPan.y = nextPan.y;
      drawScaled(currentBitmap);
    });

    function endDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      try {
        cv.releasePointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    }

    cv.addEventListener('pointerup', endDrag);
    cv.addEventListener('pointercancel', endDrag);

    btnSave.addEventListener('click', async () => {
      if (bleSending || usbSending) return;
      btnSave.disabled = true;
      try {
        const { bytes, filename } = await encodeCurrentImage();
        const blob = new Blob([bytes], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename || 'image_240.jpg';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
      } finally {
        updateActionButtons();
      }
    });

    if (btnUsb) {
      btnUsb.addEventListener('click', sendViaUsb);
      if (!secureContext) {
        btnUsb.title = 'WebSerial benötigt HTTPS oder localhost.';
        setUsbStatus('WebSerial benötigt eine sichere Herkunft. Bitte die Seite über https:// oder http://localhost ausliefern (z. B. \"python -m http.server\" nutzen) und dann erneut versuchen.');
      } else if (!serialAvailable) {
        btnUsb.title = 'WebSerial wird von diesem Browser nicht freigegeben.';
        setUsbStatus('WebSerial wird von diesem Browser/Profil nicht unterstützt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge auf dem Desktop.');
      }
    }

    btnBle.addEventListener('click', sendViaBle);

    if (!secureContext) {
      btnBle.title = 'WebBluetooth benötigt HTTPS oder localhost.';
      setBleStatus('WebBluetooth benötigt eine sichere Herkunft. Bitte die Seite über https:// oder http://localhost ausliefern (z. B. "python -m http.server" nutzen) und dann erneut versuchen.');
    } else if (!bleAvailable) {
      btnBle.title = 'WebBluetooth wird von diesem Browser nicht freigegeben.';
      setBleStatus('WebBluetooth wird von diesem Browser/Profil nicht unterstützt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge.');
    }

    updateActionButtons();
  </script>
</body>
</html>

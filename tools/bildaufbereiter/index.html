<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bilderaufbereiter für die LCD-Brosche</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 880px; margin: 2rem auto; padding: 0 1rem; background: #f8f9fb; color: #1f252d; }
    header { margin-bottom: 1rem; display: flex; align-items: flex-start; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap; }
    .header__text { flex: 1 1 320px; min-width: 0; }
    .header__logo { display: block; flex: 0 0 auto; width: 160px; margin-left: auto; order: 0; }
    .header__logo img { display: block; width: 100%; max-width: 100%; height: auto; }
    @media (max-width: 680px) {
      header { flex-direction: column; align-items: center; text-align: center; }
      .header__text { flex: 1 1 auto; }
      .header__logo { order: -1; margin-left: 0; margin-bottom: .75rem; }
    }
    h1 { font-size: clamp(1.4rem, 2.5vw, 2rem); margin: 0 0 .25rem; }
    .muted { opacity: .75; }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; margin: .75rem 0; }
    .preview { position: relative; display: block; width: 358.2857142857px; height: 350.0571428571px; margin: 2.5rem auto 0; }
    .preview__viewport { position: absolute; top: 43.7142857143px; left: 55.0285714286px; width: 240px; height: 240px; border-radius: 50%; overflow: hidden; border: 1px solid #c9c9c9; box-shadow: 0 1px 8px rgba(0,0,0,.08); background: #fff; }
    .preview__viewport::after { content: ""; position: absolute; inset: 0; border-radius: 50%; pointer-events: none; box-shadow: inset 0 0 0 1px rgba(0,0,0,.12); }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: default; }
    .preview__mask { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; object-fit: cover; }
    button, select, input[type="number"], input[type="file"] { padding: .55rem .8rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: #ffffff; color: inherit; }
    button[disabled] { opacity: .5; }
    .actions { margin: 1.5rem 0 0; }
    footer { margin-top: 2rem; font-size: .9rem; }
    code { background: rgba(127,127,127,.15); padding: .1rem .3rem; border-radius: .3rem; }
    .drop-overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; padding: 2rem; color: #1f4d8f; font-weight: 600; font-size: clamp(1.1rem, 2.5vw, 1.6rem); background: rgba(74,144,226,.14); border: 2px dashed rgba(74,144,226,.6); pointer-events: none; opacity: 0; transform: scale(1.02); transition: opacity .2s ease, transform .2s ease; z-index: 999; }
    body.drop-active .drop-overlay { opacity: 1; transform: scale(1); }
    body.drop-active .preview__viewport { border-color: #4a90e2; box-shadow: 0 0 0 4px rgba(74,144,226,.25); }
    .drop-hint { margin: -.25rem 0 0; font-size: .9rem; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
    .file-picker { display: flex; align-items: center; gap: .6rem; flex-wrap: wrap; }
    .file-picker__button { display: inline-flex; align-items: center; justify-content: center; padding: .55rem .9rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: canvas; cursor: pointer; font-weight: 400; }
    .file-picker__button:focus-visible { outline: 2px solid #4a90e2; outline-offset: 2px; }
    .version-tag { font-weight: 600; font-size: .82rem; text-transform: uppercase; letter-spacing: .08em; margin-top: .4rem; color: #4a90e2; }
    .error-modal { position: fixed; inset: 0; background: rgba(15,23,42,.55); display: none; align-items: center; justify-content: center; padding: 1.5rem; z-index: 1500; }
    .error-modal.open { display: flex; }
    .error-modal__box { background: #fff; color: inherit; border-radius: .9rem; box-shadow: 0 20px 45px rgba(15,23,42,.25); max-width: min(720px, 95vw); width: 100%; padding: 1.4rem; display: flex; flex-direction: column; gap: 1rem; }
    .error-modal__title { margin: 0; font-size: 1.1rem; font-weight: 600; }
    .error-modal__textarea { width: 100%; min-height: 220px; font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .9rem; line-height: 1.35; border-radius: .6rem; border: 1px solid #ccd3dd; padding: .75rem; resize: vertical; box-sizing: border-box; }
    .error-modal__textarea:focus-visible { outline: 2px solid #4a90e2; outline-offset: 2px; }
    .error-modal__actions { display: flex; justify-content: flex-end; gap: .75rem; }
    #manual-port-tools { margin-top: 3rem; padding: 1.5rem; border: 1px solid #d8dee9; border-radius: .9rem; background: #fff; box-shadow: 0 10px 25px rgba(15,23,42,.08); }
    #manual-port-tools h2 { margin-top: 0; margin-bottom: .75rem; font-size: 1.15rem; }
    #manual-port-tools .manual-buttons { display: flex; flex-wrap: wrap; gap: .6rem; margin-bottom: 1rem; }
    #manual-port-tools button { padding: .45rem .75rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: #f8f9fb; cursor: pointer; }
    #manual-port-tools button:disabled { opacity: .5; cursor: not-allowed; }
    #manual-port-tools .manual-input { margin-bottom: 1rem; }
    #manual-port-tools .manual-input-row { display: flex; gap: .5rem; margin-top: .35rem; }
    #manual-port-tools input[type="text"] { flex: 1 1 auto; padding: .45rem .6rem; border-radius: .6rem; border: 1px solid #c9c9c9; }
    #manual-port-tools textarea { width: 100%; margin-top: .5rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; border-radius: .6rem; border: 1px solid #ccd3dd; padding: .65rem; box-sizing: border-box; background: #0f172a; color: #f8fafc; }
    #manual-port-tools textarea:focus-visible { outline: 2px solid #4a90e2; outline-offset: 2px; }
  </style>
</head>
<body>
  <div class="drop-overlay" aria-hidden="true">Bilddatei hier ablegen, um sie zu laden</div>
  <header>
    <div class="header__text">
      <h1>Bilderaufbereiter für die LCD-Brosche</h1>
      <p class="muted">Mit dieser Anwendung kannst du deine Bilder so vorbereiten, dass sie perfekt auf der Brosche angezeigt werden. Du kannst sie anschliessend per Bluetooth, USB oder über eine SD-Karte auf die Brosche übertragen.</p>
      <p class="muted version-tag" id="tool-version"></p>
    </div>
    <a class="header__logo" href="https://www.teil3.ch" target="_blank" rel="noopener">
      <img src="teil3_logo.svg" alt="Teil3 Logo" width="160" height="95" />
    </a>
  </header>

  <div class="row">
    <div class="file-picker">
      <label class="file-picker__button" for="file">Bild auswählen…</label>
      <input id="file" type="file" accept="image/*" class="visually-hidden" />
    </div>
    <label>Zuschnitt:
      <select id="mode">
        <option value="cover">Zentriert zuschneiden (füllend)</option>
        <option value="contain">Einpassen (weiß auffüllen)</option>
      </select>
    </label>
    <label>Qualität:
      <input id="quality" type="number" min="10" max="100" value="92" style="width:5rem"> %
    </label>
  </div>
  <p class="muted drop-hint">Tipp: Ziehe eine Bilddatei irgendwo auf diese Seite – sie wird automatisch geladen.</p>

  <div class="preview">
    <div class="preview__viewport">
      <canvas id="cv" width="240" height="240"></canvas>
    </div>
    <img class="preview__mask" src="./LCD-Brosche-maske.png" alt="Maske der LCD-Brosche" />
  </div>

  <div class="actions">
    <button id="save" disabled>Als JPEG speichern</button>
    <button id="send-usb" disabled>Über USB senden</button>
    <button id="send-usb-log" disabled>USB-Log abrufen</button>
    <button id="send-ble" disabled>Per Bluetooth senden</button>
    <p id="usb-status" class="muted" aria-live="polite"></p>
    <p id="ble-status" class="muted" aria-live="polite"></p>
    <p class="muted" id="ble-hint">Hinweis: Auf der Brosche den BLE-Empfangsmodus aktivieren (BTN2 in der Diashow App mehrmals lang drücken, bis "Bluetooth Modus" angezeigt wird).</p>
  </div>

  <script type="module">
    // --- Import der MozJPEG-WASM-Codec-Factory (jSquash, auf UNPKG gehostet) ---
    // Dokumentation/Quelle: https://github.com/jamsinclair/jSquash (encode API) –
    // und Typdefinitionen der Optionen (mozjpeg_enc.d.ts)
    let moduleFactory = null;
    let mozModuleSource = 'cdn';
    const mozModuleErrors = [];
    try {
      moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;
      console.info('[MozJPEG] Encoder via CDN geladen.');
    } catch (cdnError) {
      mozModuleErrors.push(cdnError);
      console.warn('[MozJPEG] CDN-Import fehlgeschlagen, versuche lokalen Fallback …', cdnError);
      try {
        moduleFactory = (await import('./mozjpeg/mozjpeg_enc.js?module')).default;
        mozModuleSource = 'local';
        console.info('[MozJPEG] Encoder aus ./mozjpeg/ geladen.');
      } catch (localError) {
        mozModuleErrors.push(localError);
        console.error('[MozJPEG] Lokaler Fallback fehlgeschlagen.', localError);
      }
    }
    if (!moduleFactory) {
      const combinedError = mozModuleErrors.pop() || new Error('Unbekannter Importfehler');
      const message = 'MozJPEG-WASM konnte nicht geladen werden. Bitte Internetverbindung prüfen oder ./mozjpeg/ bereitstellen.';
      console.error(message, { mozModuleErrors });
      alert(message);
      throw combinedError;
    }
    window.__mozjpegSource = mozModuleSource;
    const TOOL_VERSION = 'V0.6';

    const fileInput = document.getElementById('file');
    const modeSel   = document.getElementById('mode');
    const qInput    = document.getElementById('quality');
    const btnSave   = document.getElementById('save');
    const btnUsb    = document.getElementById('send-usb');
    const btnUsbLog = document.getElementById('send-usb-log');
    const btnBle    = document.getElementById('send-ble');
    const versionLabel = document.getElementById('tool-version');
    const usbStatus = document.getElementById('usb-status');
    const bleStatus = document.getElementById('ble-status');
    const cv        = document.getElementById('cv');
    const ctx       = cv.getContext('2d', { willReadFrequently: true });
    const BLE_UUIDS = {
      service: '12345678-1234-1234-1234-1234567890ab',
      chunk:   'abcd0001-1234-1234-1234-1234567890ab',
      control: 'abcd0002-1234-1234-1234-1234567890ab'
    };
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    let currentBitmap = null;
    let moz = null;
    let mozReady = false;
    let coverPan = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };
    let dropDepth = 0;
    let currentDownloadName = 'image_240.jpg';
    let bleSending = false;
    let usbSending = false;
    const usbDebugLog = [];
    let usbErrorModal = null;
    let usbErrorModalText = null;
    let usbErrorModalCopyBtn = null;
    let usbErrorModalCloseBtn = null;
    let usbErrorModalKeyHandlerAttached = false;

    const manualLogEntries = [];
    let manualLogOutput = null;
    let manualCmdInput = null;
    let manualCmdButton = null;
    let manualOpenButton = null;
    let manualPingButton = null;
    let manualStartButton = null;
    let manualEndButton = null;
    let manualLogButton = null;
    let manualCloseButton = null;
    let manualCopyButton = null;
    let manualPort = null;
    let manualReader = null;
    let manualWriter = null;
    let manualReadableClosed = null;

    if (versionLabel) {
      versionLabel.textContent = `${TOOL_VERSION} · mozjpeg: ${mozModuleSource}`;
    }

    const secureContextHosts = new Set(['localhost', '127.0.0.1', '::1']);
    const secureContext = window.isSecureContext || secureContextHosts.has(location.hostname);
    const bleAvailable = 'bluetooth' in navigator;
    const bleSupported = secureContext && bleAvailable;
    const serialAvailable = 'serial' in navigator;
    const usbSupported = secureContext && serialAvailable;

    function setUsbStatus(text) {
      if (!usbStatus) return;
      usbStatus.textContent = text || '';
    }

    function appendManualLog(line) {
      const timestamp = new Date().toISOString().replace('T', ' ').replace(/\..+$/, '');
      const entry = `[${timestamp}] ${line}`;
      manualLogEntries.push(entry);
      if (manualLogEntries.length > 400) {
        manualLogEntries.shift();
      }
      if (manualLogOutput) {
        manualLogOutput.value = manualLogEntries.join('\n');
        manualLogOutput.scrollTop = manualLogOutput.scrollHeight;
      }
      if (manualCopyButton) {
        manualCopyButton.disabled = manualLogEntries.length === 0;
      }
    }

    function usbLog(direction, message) {
      const entry = `${direction} ${message}`;
      if (usbDebugLog.length >= 80) {
        usbDebugLog.shift();
      }
      usbDebugLog.push(entry);
      console.debug('[USB LOG]', entry);
      appendManualLog(entry);
    }

    function usbLogSnapshot() {
      return usbDebugLog.slice(-12).join('\n');
    }

    function ensureUsbErrorModal() {
      if (usbErrorModal) return usbErrorModal;
      const overlay = document.createElement('div');
      overlay.className = 'error-modal';

      const box = document.createElement('div');
      box.className = 'error-modal__box';

      const title = document.createElement('h2');
      title.className = 'error-modal__title';
      title.textContent = 'USB-Fehlerdetails';

      const textarea = document.createElement('textarea');
      textarea.className = 'error-modal__textarea';
      textarea.setAttribute('readonly', 'readonly');

      const actions = document.createElement('div');
      actions.className = 'error-modal__actions';

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.textContent = 'In Zwischenablage kopieren';

      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.textContent = 'Schliessen';

      actions.appendChild(copyBtn);
      actions.appendChild(closeBtn);
      box.appendChild(title);
      box.appendChild(textarea);
      box.appendChild(actions);
      overlay.appendChild(box);
      document.body.appendChild(overlay);

      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(textarea.value);
          copyBtn.textContent = 'Kopiert ✔';
          setTimeout(() => { copyBtn.textContent = 'In Zwischenablage kopieren'; }, 1600);
        } catch (err) {
          console.warn('Clipboard write failed', err);
        }
        textarea.focus();
        textarea.select();
      });

      closeBtn.addEventListener('click', () => {
        overlay.classList.remove('open');
      });

      overlay.addEventListener('click', (evt) => {
        if (evt.target === overlay) {
          overlay.classList.remove('open');
        }
      });

      if (!usbErrorModalKeyHandlerAttached) {
        document.addEventListener('keydown', (evt) => {
          if (evt.key === 'Escape' && overlay.classList.contains('open')) {
            overlay.classList.remove('open');
          }
        });
        usbErrorModalKeyHandlerAttached = true;
      }

      usbErrorModal = overlay;
      usbErrorModalText = textarea;
      usbErrorModalCopyBtn = copyBtn;
      usbErrorModalCloseBtn = closeBtn;
      return overlay;
    }

    function showUsbErrorDialog(message) {
      const overlay = ensureUsbErrorModal();
      if (!usbErrorModalText) return;
      usbErrorModalText.value = message;
      if (usbErrorModalCopyBtn) {
        usbErrorModalCopyBtn.textContent = 'In Zwischenablage kopieren';
      }
      requestAnimationFrame(() => {
        overlay.classList.add('open');
        usbErrorModalText.focus();
        usbErrorModalText.select();
      });
    }

    async function alertUsbError(message) {
      const header = `Version ${TOOL_VERSION}`;
      const baseMessage = header ? `${header}\n${message}` : message;
      const log = usbLogSnapshot();
      const fullMessage = log ? `${baseMessage}\n\nLetzte USB-Meldungen:\n${log}` : baseMessage;
      console.error('USB ERROR:', baseMessage, { log: usbDebugLog.slice() });
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(fullMessage);
          usbLog('<>', 'Fehlerdetails in die Zwischenablage kopiert.');
        } catch (err) {
          usbLog('!!', `Clipboard write failed: ${err?.message || err}`);
        }
      }
      try {
        showUsbErrorDialog(fullMessage);
      } catch (err) {
        console.warn('Fallback alert (Dialog fehlgeschlagen)', err);
        alert(fullMessage);
      }
    }

    function setBleStatus(text) {
      if (!bleStatus) return;
      bleStatus.textContent = text || '';
    }

    function ensureManualPortTools() {
      if (manualLogOutput) return;
      const section = document.createElement('section');
      section.id = 'manual-port-tools';
      section.innerHTML = `
        <h2>USB Direktsteuerung</h2>
        <p class="muted">Öffne hier den Port und sende manuell Kommandos wie <code>PING</code>, <code>START</code> oder <code>LOG</code>. Antworten erscheinen im Log.</p>
        <div class="manual-buttons">
          <button type="button" id="manual-open">Port auswählen &amp; öffnen</button>
          <button type="button" id="manual-ping" disabled>Send PING</button>
          <button type="button" id="manual-start" disabled>Send START 0 test.bin</button>
          <button type="button" id="manual-end" disabled>Send END</button>
          <button type="button" id="manual-log" disabled>Send LOG</button>
          <button type="button" id="manual-close" disabled>Port schließen</button>
          <button type="button" id="manual-copy" disabled>Log kopieren</button>
        </div>
        <div class="manual-input">
          <label for="manual-cmd">Eigener Befehl</label>
          <div class="manual-input-row">
            <input type="text" id="manual-cmd" placeholder="z. B. START 4096 test.jpg" autocomplete="off" />
            <button type="button" id="manual-send" disabled>Senden</button>
          </div>
        </div>
        <label for="manual-log-output">Serielles Log</label>
        <textarea id="manual-log-output" rows="16" readonly spellcheck="false"></textarea>
      `;
      document.body.appendChild(section);

      manualLogOutput = section.querySelector('#manual-log-output');
      manualCmdInput = section.querySelector('#manual-cmd');
      manualCmdButton = section.querySelector('#manual-send');
      manualOpenButton = section.querySelector('#manual-open');
      manualPingButton = section.querySelector('#manual-ping');
      manualStartButton = section.querySelector('#manual-start');
      manualEndButton = section.querySelector('#manual-end');
      manualLogButton = section.querySelector('#manual-log');
      manualCloseButton = section.querySelector('#manual-close');
      manualCopyButton = section.querySelector('#manual-copy');

      const encoder = new TextEncoder();

      const resetUi = () => {
        manualPingButton.disabled = true;
        manualStartButton.disabled = true;
        manualEndButton.disabled = true;
        manualLogButton.disabled = true;
        manualCloseButton.disabled = true;
        manualCmdButton.disabled = true;
        manualCopyButton.disabled = manualLogEntries.length === 0;
        manualOpenButton.disabled = false;
      };

      const closePort = async () => {
        if (!manualPort) return;
        appendManualLog('== Port schließen …');
        try {
          if (manualReader) await manualReader.cancel().catch(() => {});
        } catch (_) {}
        try {
          if (manualReadableClosed) await manualReadableClosed.catch(() => {});
        } catch (_) {}
        try {
          if (manualWriter) await manualWriter.releaseLock();
        } catch (_) {}
        try {
          await manualPort.close();
        } catch (err) {
          appendManualLog(`!! close error: ${err?.message || err}`);
        }
        manualPort = null;
        manualReader = null;
        manualWriter = null;
        manualReadableClosed = null;
        resetUi();
        appendManualLog('== Port geschlossen');
      };

      const sendManual = async (text) => {
        if (!manualWriter) throw new Error('Writer nicht bereit');
        appendManualLog(`-> ${text.trim()}`);
        try {
          await manualWriter.write(encoder.encode(text));
          await manualWriter.ready?.catch(() => {});
        } catch (err) {
          appendManualLog(`!! write error: ${err?.message || err}`);
          throw err;
        }
      };

      const openPort = async () => {
        if (!serialAvailable) {
          appendManualLog('!! WebSerial wird nicht unterstützt');
          return;
        }
        if (manualPort) {
          appendManualLog('== Port bereits geöffnet');
          return;
        }
        manualOpenButton.disabled = true;
        try {
          appendManualLog('== openPort() gestartet');
          const known = await navigator.serial.getPorts();
          if (known.length > 0) {
            manualPort = known[0];
            appendManualLog(`== Nutze vorhandene Berechtigung (${known.length} Port${known.length>1?'s':''})`);
          }
          if (!manualPort) {
            appendManualLog('== Portauswahl …');
            manualPort = await navigator.serial.requestPort();
          }
          appendManualLog('== Öffne Port …');
          await manualPort.open({ baudRate: 115200, dataBits: 8, stopBits: 1, parity: 'none' });
          appendManualLog('== Port geöffnet');
        } catch (err) {
          appendManualLog(`!! open failed: ${err?.message || err}`);
          manualPort = null;
          manualOpenButton.disabled = false;
          return;
        }

        const decoderStream = new TextDecoderStream();
        manualReadableClosed = manualPort.readable.pipeTo(decoderStream.writable).catch(() => {});
        manualReader = decoderStream.readable.getReader();
        manualWriter = manualPort.writable.getWriter();

        (async () => {
          appendManualLog('== Reader gestartet');
          try {
            while (manualReader && manualPort) {
              const { value, done } = await manualReader.read();
              if (done) {
                appendManualLog('== Reader done');
                break;
              }
              if (value) {
                const lines = value.split(/\r?\n/);
                for (const line of lines) {
                  if (line) appendManualLog(`<= ${line}`);
                }
              }
            }
          } catch (err) {
            appendManualLog(`!! reader error: ${err?.message || err}`);
          }
        })();

        manualPingButton.onclick = () => sendManual('PING\n');
        manualStartButton.onclick = () => sendManual('START 0 test.bin\n');
        manualEndButton.onclick = () => sendManual('END\n');
        manualLogButton.onclick = () => sendManual('LOG\n');
        manualCmdButton.onclick = () => {
          const line = manualCmdInput.value.trim();
          if (!line) return;
          sendManual(line + '\n').catch(() => {});
          manualCmdInput.value = '';
          manualCmdInput.focus();
        };

        manualCloseButton.onclick = () => closePort();
        manualCopyButton.onclick = async () => {
          const text = manualLogEntries.join('\n');
          if (!text) return;
          try {
            await navigator.clipboard.writeText(text);
            appendManualLog('== Log in Zwischenablage kopiert');
          } catch (err) {
            appendManualLog(`!! Clipboard-Fehler: ${err?.message || err}`);
          }
        };

        manualPingButton.disabled = false;
        manualStartButton.disabled = false;
        manualEndButton.disabled = false;
        manualLogButton.disabled = false;
        manualCloseButton.disabled = false;
        manualCmdButton.disabled = false;
        manualCopyButton.disabled = manualLogEntries.length === 0;
      };

      manualOpenButton.addEventListener('click', () => {
        if (manualPort) {
          appendManualLog('== Port bereits geöffnet');
          return;
        }
        openPort().catch((err) => appendManualLog(`!! openPort error: ${err?.message || err}`));
      });

      manualCmdInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !manualCmdButton.disabled) {
          event.preventDefault();
          manualCmdButton.click();
        }
      });

      resetUi();
    }

    function updateActionButtons() {
      const ready = !!currentBitmap && mozReady;
      const busy = bleSending || usbSending;
      if (btnSave) btnSave.disabled = !ready || busy;
      if (btnUsb) btnUsb.disabled = !ready || !usbSupported || busy;
      if (btnUsbLog) btnUsbLog.disabled = !usbSupported || busy;
      if (btnBle) btnBle.disabled = !ready || !bleSupported || busy;
    }

    function sanitizeFilenameForTransfer(name) {
      const fallback = 'ble_image.jpg';
      if (!name) return fallback;
      let base = name.split(/[\\/]/).pop() || fallback;
      base = base.toLowerCase();
      let out = '';
      for (const ch of base) {
        if ((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch === '-' || ch === '_' || ch === '.') {
          out += ch;
        } else if (ch === ' ') {
          out += '_';
        }
        if (out.length >= 60) break;
      }
      if (!out) out = fallback;
      if (out.startsWith('.')) out = out.substring(1) || fallback;
      if (!out.endsWith('.jpg') && !out.endsWith('.jpeg')) {
        out += '.jpg';
      }
      if (out.length > 60) {
        const idx = out.lastIndexOf('.');
        const ext = idx >= 0 ? out.slice(idx) : '.jpg';
        const stem = idx >= 0 ? out.slice(0, idx) : out;
        out = stem.slice(0, Math.max(1, 60 - ext.length)) + ext;
      }
      return out;
    }

    function humanReadableSize(bytes) {
      if (!Number.isFinite(bytes)) return '0 B';
      if (bytes < 1024) return `${bytes} B`;
      const kb = bytes / 1024;
      const rounded = Math.round(kb * 10) / 10;
      return `${rounded.toFixed(rounded % 1 === 0 ? 0 : 1)} KB`;
    }

    async function encodeCurrentImage() {
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        throw new Error('Kein Bild geladen');
      }
      const ready = await initMozIfNeeded();
      if (!ready || !moz) {
        throw new Error('JPEG-Codec nicht verfügbar');
      }
      const { data } = ctx.getImageData(0, 0, cv.width, cv.height);
      const quality = Math.min(100, Math.max(10, parseInt(qInput.value, 10) || 92));
      const opts = {
        quality,
        baseline: true,
        progressive: false,
        arithmetic: false,
        optimize_coding: true,
        smoothing: 0,
        color_space: 3,
        quant_table: 3,
        trellis_multipass: false,
        trellis_opt_zero: false,
        trellis_opt_table: false,
        trellis_loops: 1,
        auto_subsample: false,
        chroma_subsample: 2,
        separate_chroma_quality: false,
        chroma_quality: quality
      };

      try {
        const jpegU8 = moz.encode(data, 240, 240, opts);
        if (isProgressiveJPEG(jpegU8)) {
          alert('Warnung: Der erzeugte JPEG scheint progressiv zu sein.');
        }
        return {
          bytes: jpegU8,
          filename: currentDownloadName || 'image_240.jpg'
        };
      } catch (error) {
        console.error(error);
        alert('Fehler beim JPEG-Encode: ' + (error?.message || error));
        throw error;
      }
    }

    async function writeBle(characteristic, data) {
      await characteristic.writeValue(data);
    }

    async function waitFor(predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (performance.now() < deadline) {
        if (predicate()) return true;
        await delay(50);
      }
      return predicate();
    }

    function createLineReader(reader) {
      let buffer = '';
      return {
        async readLine(timeoutMs) {
          const deadline = (typeof timeoutMs === 'number')
            ? performance.now() + timeoutMs
            : null;
          while (true) {
            const newlineIdx = buffer.indexOf('\n');
            if (newlineIdx >= 0) {
              const line = buffer.slice(0, newlineIdx);
              buffer = buffer.slice(newlineIdx + 1);
              return line.replace(/\r$/, '');
            }

            const readPromise = reader.read();
            let result;
            if (deadline !== null) {
              const remaining = deadline - performance.now();
              if (remaining <= 0) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
              result = await Promise.race([
                readPromise,
                delay(Math.max(remaining, 0)).then(() => ({ timeout: true })),
              ]);
              if (result?.timeout) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
            } else {
              result = await readPromise;
            }

            if (result.done) {
              if (buffer.length > 0) {
                const line = buffer;
                buffer = '';
                return line.replace(/\r$/, '');
              }
              throw new Error('Verbindung geschlossen');
            }
            if (result.value) {
              buffer += result.value;
            }
          }
        }
      };
    }

    async function waitForUsbLine(lineReader, predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (true) {
        const remaining = deadline - performance.now();
        if (remaining <= 0) {
          throw new Error('Timeout beim Warten auf Antwort des Geräts');
        }
        const line = (await lineReader.readLine(Math.max(remaining, 50))).trim();
        if (!line) continue;
        usbLog('<=', line);
        if (!line.startsWith('USB')) {
          continue;
        }
        const payload = line.slice(3).trimStart();
        if (payload.startsWith('ERR')) {
          const message = payload.substring(3).trim();
          throw new Error(message || 'Gerätefehler');
        }
        if (payload.startsWith('OK PROG')) {
          const parts = payload.split(/\s+/);
          if (parts.length >= 4) {
            const received = Number(parts[2]);
            const total = Number(parts[3]);
            if (Number.isFinite(received) && Number.isFinite(total) && total > 0) {
              const pct = Math.min(100, Math.round((received / total) * 100));
              setUsbStatus(`Gerät empfängt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          }
          continue;
        }
        if (payload.startsWith('OK MSG')) {
          const msg = payload.substring(6).trim();
          if (msg) setUsbStatus(msg);
          continue;
        }
        if (predicate(payload)) {
          return payload;
        }
      }
    }

    async function dumpDeviceLog(lineReader, writer, maxEntries = 16) {
      if (!writer || !lineReader) return [];
      try {
        usbLog('->', 'LOG');
        await writer.write(textEncoder.encode('LOG\n'));
      } catch (err) {
        usbLog('!!', `LOG senden fehlgeschlagen: ${err?.message || err}`);
        return [];
      }

      let ack;
      try {
        ack = await waitForUsbLine(
          lineReader,
          (payload) => payload.startsWith('OK LOG') || payload.startsWith('ERR'),
          2000
        );
      } catch (err) {
        usbLog('!!', `LOG-Antwort ausstehend: ${err?.message || err}`);
        return [];
      }

      if (ack.startsWith('ERR')) {
        usbLog('!!', `Gerät meldet LOG-Fehler: ${ack}`);
        return [];
      }

      const parts = ack.split(/\s+/);
      let count = Number(parts[2]);
      if (!Number.isFinite(count) || count <= 0) {
        count = maxEntries;
      }
      const limit = Math.min(count, Math.max(1, maxEntries));
      const entries = [];
      let guard = 0;

      while (entries.length < limit && guard < limit + 8) {
        guard += 1;
        try {
          const raw = (await lineReader.readLine(800)).trim();
          if (!raw) continue;
          usbLog('<=', raw);
          if (raw.startsWith('USB LOG')) {
            entries.push(raw.substring(7).trim());
          }
        } catch (err) {
          if (entries.length === 0) {
            usbLog('!!', `LOG lesen fehlgeschlagen: ${err?.message || err}`);
          } else {
            usbLog('<>', 'LOG lesen beendet (Timeout)');
          }
          break;
        }
      }

      if (!entries.length) {
        usbLog('<>', 'Keine LOG-Einträge vom Gerät erhalten.');
      }
      return entries;
    }

    async function sendViaUsb() {
      if (!usbSupported) {
        alert('WebSerial wird von diesem Browser nicht unterstützt. Bitte Chrome oder Edge auf dem Desktop verwenden.');
        return;
      }
      if (usbSending || bleSending) return;
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        return;
      }

      usbDebugLog.length = 0;

      let port = null;
      let writer = null;
      let reader = null;
      let readableClosed = null;
      let lineReader = null;
      let transferCompleted = false;
      const chunkSize = 1024;
      let sent = 0;
      let totalSize = 0;
      let totalLabel = '0 B';

      try {
        usbSending = true;
        updateActionButtons();
        setUsbStatus('Bild wird vorbereitet …');
        usbLog('<>', 'Beginne USB-Transfer');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);
        totalSize = bytes.length;
        totalLabel = humanReadableSize(totalSize);

        setUsbStatus('Seriellen Port auswählen …');
        port = await navigator.serial.requestPort();
        try {
          await port.open({ baudRate: 115200, dataBits: 8, stopBits: 1, parity: 'none', flowControl: 'none' });
        } catch (err) {
          usbLog('!!', `open failed: ${err?.message || err}`);
          throw err;
        }

        // Versuche nur DTR auf HIGH zu setzen. Einige Systeme melden zwar Fehler,
        // aber wenn es klappt, bleibt die Brosche im Transfer-Modus.
        let dtrPinned = false;
        try {
          const info = port.getInfo ? port.getInfo() : {};
          usbLog('<>', `Port geöffnet (vendor=${info.usbVendorId || 'n/a'} product=${info.usbProductId || 'n/a'})`);
        } catch (_) {
          usbLog('<>', 'Port geöffnet (Info nicht verfügbar)');
        }
        if (typeof port.setSignals === 'function') {
          usbLog('<>', 'setSignals übersprungen (CH9102 toleranz)');
        } else {
          usbLog('<>', 'setSignals nicht verfügbar – behalten Standardpegel bei');
        }
        if (!port.writable) {
          throw new Error('Port bietet keinen Schreibstream.');
        }
        if (!port.readable) {
          throw new Error('Port bietet keinen Lesestream.');
        }

        if (typeof TextDecoderStream === 'undefined') {
          throw new Error('TextDecoderStream wird nicht unterstützt. Bitte einen aktuellen Chromium-Browser verwenden.');
        }
        const decoder = new TextDecoderStream();
        readableClosed = port.readable.pipeTo(decoder.writable).catch(() => {});
        reader = decoder.readable.getReader();
        lineReader = createLineReader(reader);

        if (!dtrPinned) {
          setUsbStatus('USB-Port geöffnet – falls die Brosche neu startet, Transfer-Modus erneut aktivieren.');
        }

        await delay(400);
        const drainDeadline = performance.now() + 600;
        while (performance.now() < drainDeadline) {
          try {
            const remaining = Math.max(drainDeadline - performance.now(), 50);
            const line = await lineReader.readLine(remaining);
            if (!line) continue;
            usbLog('<=', `(pre) ${line}`);
          } catch (drainErr) {
            const msg = drainErr?.message || '';
            if (msg.includes('Timeout beim Lesen')) {
              break;
            }
            if (msg.includes('Verbindung geschlossen')) {
              throw drainErr;
            }
            usbLog('!!', `Drain-Leseproblem: ${msg || drainErr}`);
            break;
          }
        }

        const bootLines = [];
        const strayLines = [];
        let readyFromBoot = false;
        const bootDeadline = performance.now() + 1000;
        while (performance.now() < bootDeadline) {
          try {
            const remaining = Math.max(bootDeadline - performance.now(), 50);
            const line = await lineReader.readLine(remaining);
            if (!line) continue;
            usbLog('<=', line);
            const trimmed = line.trim();
            if (!trimmed) continue;
            if (trimmed.startsWith('USB')) {
              const payload = trimmed.slice(3).trimStart();
              if (payload.startsWith('OK READY') || payload.startsWith('OK PONG')) {
                readyFromBoot = true;
                setUsbStatus('Gerät meldet Bereitschaft – warte auf Start …');
                continue;
              }
              continue;
            }
            const looksLikeReset = trimmed.startsWith('ets ') ||
                                   trimmed.startsWith('rst:') ||
                                   trimmed.includes('[BOOT]');
            if (looksLikeReset) {
              bootLines.push(trimmed);
              continue;
            }
            const looksLikeAppLog = trimmed.startsWith('[') ||
                                     trimmed.startsWith('logical=') ||
                                     trimmed.includes(' logical=') ||
                                     trimmed.startsWith('USB LOG ') ||
                                     trimmed.startsWith('USB OK ') ||
                                     trimmed.startsWith('USB ERR ');
            if (looksLikeAppLog) {
              // Debug- oder Statusausgaben ignorieren – sie stammen typischerweise von BTN/Slideshow.
              continue;
            }
            strayLines.push(trimmed);
          } catch (err) {
            const msg = err?.message || '';
            if (msg.includes('Timeout beim Lesen')) {
              break;
            }
            if (msg.includes('Verbindung geschlossen')) {
              setUsbStatus('USB-Verbindung verloren – vermutlich hat die Brosche neu gestartet.');
              throw new Error('Gerät hat den Port unmittelbar nach dem Öffnen geschlossen (vermutlich Reset). Bitte BTN2 lang halten, bis \"USB-Transfer\" angezeigt wird, und erneut versuchen.');
            }
            throw err;
          }
        }
        if (bootLines.length > 0) {
          setUsbStatus('Brosche hat neu gestartet – bitte BTN2 lang halten, bis \"USB-Transfer\" angezeigt wird.');
          throw new Error('Gerät hat neu gestartet. Transfer-Modus erneut aktivieren und noch einmal versuchen.');
        }
        if (strayLines.length > 0) {
          const preview = strayLines.slice(0, 2).join(' | ');
          usbLog('!!', `Ignoriere Nicht-USB-Ausgabe vor Handshake: ${preview}`);
        }

        writer = port.writable.getWriter();

        const writeCommand = async (text) => {
          const data = textEncoder.encode(text);
          await writer.write(data);
          if (writer.ready) {
            try {
              await writer.ready;
            } catch (err) {
              usbLog('!!', `writer.ready rejected: ${err?.message || err}`);
            }
          }
        };

        // Vorab Verbindung prüfen (PING). Wenn wir keine Antwort erhalten,
        // brechen wir ab, weil das Gerät vermutlich im falschen Modus ist.
        usbLog('<>', 'Warte auf Gerätebereit (post-open delay)…');
        await delay(1200);

        let pingAcknowledged = readyFromBoot;
        if (pingAcknowledged) {
          usbLog('<>', 'Bereitschaft aus Vorlogs erkannt – PING optional');
        }
        for (let attempt = 0; attempt < 3 && !pingAcknowledged; ++attempt) {
          const label = attempt === 0 ? 'PING' : `PING (Versuch ${attempt + 1})`;
          usbLog('->', label);
          try {
            await writeCommand('PING\n');
          } catch (err) {
            usbLog('!!', `Senden von ${label} fehlgeschlagen: ${err?.message || err}`);
            if (attempt >= 2) {
              throw new Error('PING konnte nicht gesendet werden. Bitte Verbindung prüfen.');
            }
            await delay(200);
            continue;
          }

          try {
            const reply = await waitForUsbLine(
              lineReader,
              (payload) => payload.startsWith('OK PONG') || payload.startsWith('OK READY'),
              3500
            );
            if (reply.startsWith('OK PONG')) {
              setUsbStatus('Gerät antwortet – Übertragung wird vorbereitet …');
              pingAcknowledged = true;
              break;
            }
            if (reply.startsWith('OK READY')) {
              setUsbStatus('Gerät meldet Bereitschaft – Übertragung wird vorbereitet …');
              pingAcknowledged = true;
              break;
            }
          } catch (err) {
            usbLog('!!', `PING-Antwort fehlgeschlagen (Versuch ${attempt + 1}): ${err?.message || err}`);
            if (attempt >= 2) {
              throw new Error('Kein PING von der Brosche empfangen. Bitte Transfer-Modus (BTN2 lang halten) und USB-Kabel prüfen.');
            }
            await delay(300);
          }
        }

        if (!pingAcknowledged) {
          throw new Error('Kein PING von der Brosche empfangen. Bitte Transfer-Modus (BTN2 lang halten) und USB-Kabel prüfen.');
        }

        const startLine = `START ${totalSize} ${sanitizedName}\n`;
        usbLog('->', startLine.trim());
        await writer.write(textEncoder.encode(startLine));

        let startAck = null;
        try {
          startAck = await waitForUsbLine(
            lineReader,
            // Wir ziehen die relevanten USB-Zeilen heraus und lassen Debug-Text ignorieren.
            (payload) => payload.startsWith('OK READY') ||
                         payload.startsWith('OK START') ||
                         payload.startsWith('ERR'),
            6000
          );
        } catch (err) {
          usbLog('!!', `Keine START-Bestätigung innerhalb 6s: ${err?.message || err}`);
        }

        if (startAck) {
          usbLog('<=', startAck);
          if (startAck.startsWith('OK READY')) {
            usbLog('<>', 'READY bestätigt – warte auf OK START');
            try {
              startAck = await waitForUsbLine(
                lineReader,
                (payload) => payload.startsWith('OK START') || payload.startsWith('ERR'),
                6000
              );
              usbLog('<=', startAck);
            } catch (err) {
              usbLog('!!', `Kein OK START nach READY: ${err?.message || err}`);
            }
          }
        }

        if (startAck && startAck.startsWith('OK START')) {
          let deviceFilename = sanitizedName;
          const parts = startAck.split(/\s+/);
          if (parts.length >= 3) {
            deviceFilename = parts[2];
          }
          setUsbStatus(`Übertragung gestartet (${deviceFilename})`);
          usbLog('<>', `Transfer bestätigt: ${deviceFilename}`);
        } else if (startAck && startAck.startsWith('ERR')) {
          usbLog('!!', `Gerät meldet Fehler vor Datenstart: ${startAck}`);
          setUsbStatus(`Gerätefehler: ${startAck}`);
          throw new Error(startAck);
        } else {
          const noAckMsg = 'Keine START-Bestätigung vom Gerät empfangen. Bitte sicherstellen, dass der Transfer-Modus aktiv ist (BTN2 lang halten, bis \"Transfer\" erscheint).';
          usbLog('!!', noAckMsg);
          setUsbStatus(noAckMsg);
          throw new Error(noAckMsg);
        }

        setUsbStatus(`Sende 0% (0 / ${totalLabel})`);

        for (let offset = 0; offset < totalSize; offset += chunkSize) {
          const slice = bytes.subarray(offset, Math.min(offset + chunkSize, totalSize));
          await writer.write(slice);
          sent += slice.length;
          usbLog('->', `DATA ${sent}/${totalSize} (+${slice.length})`);

          if (sent === totalSize || sent <= chunkSize || (sent % (chunkSize * 12)) === 0) {
            const pct = Math.min(100, Math.round((sent / totalSize) * 100));
            setUsbStatus(`Sende ${pct}% (${humanReadableSize(sent)} / ${totalLabel})`);
          }
          await delay(3);
        }

        usbLog('->', 'END');
        await writer.write(textEncoder.encode('END\n'));

        const endPredicate = (payload) => {
          if (payload.startsWith('OK END')) {
            return true;
          }
          if (payload.startsWith('OK PROG')) {
            const parts = payload.split(/\s+/);
            if (parts.length >= 4) {
              const received = Number(parts[2]);
              const total = Number(parts[3]);
              if (Number.isFinite(received) && Number.isFinite(total) && total > 0 && received >= total) {
                return true;
              }
            }
          }
          return false;
        };

        const endAck = await waitForUsbLine(lineReader, endPredicate, 16000);
        if (endAck.startsWith('OK PROG')) {
          setUsbStatus('Übertragung abgeschlossen ✅ (Bestätigung über Fortschrittsmeldung)');
        } else {
          const endParts = endAck.split(/\s+/);
          if (endParts.length >= 3) {
            setUsbStatus(`Übertragung abgeschlossen ✅ (${endParts[2]})`);
          } else {
            setUsbStatus('Übertragung abgeschlossen ✅');
          }
        }
        transferCompleted = true;
        } catch (error) {
          console.error(error);
          const name = error?.name;
          let userMessage = '';
          let fetchLog = false;
          usbLog('<>', `HOST SENT ${sent}/${totalSize}`);

          if (name === 'NotFoundError') {
            setUsbStatus('USB-Senden abgebrochen – kein Port ausgewählt.');
            userMessage = 'USB-Senden abgebrochen – kein Port ausgewählt.';
          } else if (name === 'AbortError') {
            setUsbStatus('USB-Senden abgebrochen.');
            userMessage = 'USB-Senden abgebrochen.';
          } else if (name === 'NetworkError' || /device has been lost/i.test(error?.message || '')) {
            const detail = error?.message ? ` (${error.message})` : '';
            if (transferCompleted) {
              setUsbStatus('Übertragung abgeschlossen ✅ (Gerät hat den Port getrennt).');
              userMessage = '';
            } else {
              setUsbStatus(`USB-Verbindung verloren – bitte Brosche neu verbinden und Transfer-Modus erneut aktivieren.${detail ? ' ' + detail : ''}`);
              userMessage = `USB-Verbindung verloren. Bitte den ESP32 neu verbinden, Transfer-Modus (BTN2 lang) aktivieren und erneut senden.${detail ? `\nOriginalfehler: ${detail.trim()}` : ''}`;
              fetchLog = true;
            }
          } else if (/timeout beim warten/i.test(error?.message || '')) {
            setUsbStatus('Timeout – keine Antwort vom Gerät. Ist der Transfer-Modus aktiv (BTN2 lang in der Diashow)?');
            userMessage = 'Keine Antwort vom Gerät erhalten. Bitte sicherstellen, dass die Brosche im Transfer-Modus ist (BTN2 lang halten, bis "Transfer" angezeigt wird) und erneut versuchen.';
            fetchLog = true;
          } else {
            const message = error?.message || error?.toString() || 'Unbekannter Fehler';
            setUsbStatus(`Fehler: ${message}`);
            userMessage = 'Fehler beim USB-Senden: ' + message;
            fetchLog = true;
          }

          if (fetchLog && writer && lineReader) {
            try {
              await dumpDeviceLog(lineReader, writer, 20);
            } catch (logErr) {
              console.warn('Dump device log failed', logErr);
            }
          }

          if (userMessage) {
            await alertUsbError(userMessage);
          }
      } finally {
        try {
          if (writer) {
            usbLog('<>', 'release writer');
            await writer.releaseLock();
          }
        } catch (_) { /* ignore */ }
        try {
          if (reader) {
            usbLog('<>', 'cancel reader');
            await reader.cancel();
          }
        } catch (_) { /* ignore */ }
        try {
          if (readableClosed) {
            usbLog('<>', 'await readable close');
            await readableClosed.catch(() => {});
          }
        } catch (_) { /* ignore */ }
        try {
          if (port) {
            usbLog('<>', 'close port');
            await port.close();
          }
        } catch (_) { /* ignore */ }
        usbSending = false;
        updateActionButtons();
      }
    }

    async function sendViaBle() {
      if (!bleSupported) {
        alert('WebBluetooth wird von diesem Browser nicht unterstützt. Bitte Chrome, Edge oder Android Chrome verwenden.');
        return;
      }
      if (bleSending || usbSending) return;
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild auswählen.');
        return;
      }

      let device = null;
      let server = null;
      let control = null;
      let chunk = null;
      let notifyHandler = null;
      let startConfirmed = false;
      let remoteError = null;
      let remoteDone = false;

      try {
        bleSending = true;
        updateActionButtons();
        setBleStatus('Bild wird vorbereitet …');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);

        setBleStatus('Bitte Brosche auswählen …');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Brosche' }],
          optionalServices: [BLE_UUIDS.service]
        });
        device.addEventListener('gattserverdisconnected', () => {
          if (!remoteDone) {
            setBleStatus('BLE-Verbindung getrennt');
          }
        });

        setBleStatus('Verbindung wird hergestellt …');
        server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_UUIDS.service);
        control = await service.getCharacteristic(BLE_UUIDS.control);
        chunk = await service.getCharacteristic(BLE_UUIDS.chunk);

        console.debug('BLE control props', control.properties);
        console.debug('BLE chunk props', chunk.properties);

        setBleStatus('Aktiviere Statusmeldungen …');
        try {
          await control.startNotifications();
        } catch (err) {
          throw new Error('startNotifications fehlgeschlagen: ' + (err?.message || err));
        }

        notifyHandler = (event) => {
          const value = event.target.value;
          const text = textDecoder.decode(value);
          if (!text) return;
          console.log('[BLE] Status', text);
          if (text.startsWith('OK:START')) {
            startConfirmed = true;
            setBleStatus(`Übertragung gestartet (${sanitizedName})`);
          } else if (text.startsWith('OK:PROG:')) {
            const parts = text.split(':');
            if (parts.length >= 4) {
              const received = Number(parts[2]) || 0;
              const total = Number(parts[3]) || 0;
              const pct = total ? Math.min(100, Math.round((received / total) * 100)) : 0;
              setBleStatus(`Brosche empfängt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          } else if (text.startsWith('OK:END')) {
            remoteDone = true;
            setBleStatus('Übertragung abgeschlossen.');
          } else if (text.startsWith('ERR:')) {
            remoteError = text.substring(4) || 'Unbekannter Fehler';
            setBleStatus(`Fehler vom Gerät: ${remoteError}`);
          }
        };
        control.addEventListener('characteristicvaluechanged', notifyHandler);

        const startPayload = `START:${bytes.length}:${sanitizedName}`;
        try {
          await writeBle(control, textEncoder.encode(startPayload));
        } catch (err) {
          throw new Error('START schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        const startOk = await waitFor(() => startConfirmed || remoteError, 2000);
        if (remoteError) throw new Error(remoteError);
        if (!startOk) {
          throw new Error('Keine Rückmeldung vom Gerät (BLE-Modus aktiv?).');
        }

        setBleStatus('Sende Bilddaten …');
        const chunkSize = 20;
        for (let offset = 0; offset < bytes.length; offset += chunkSize) {
          const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
          try {
            await writeBle(chunk, slice);
          } catch (err) {
            throw new Error(`Chunk @${offset} (${slice.length} B) fehlgeschlagen: ${err?.message || err}`);
          }
          if (remoteError) break;
          if ((offset / chunkSize) % 24 === 0) {
            const sent = offset + slice.length;
            const percent = Math.min(100, Math.round((sent / bytes.length) * 100));
            setBleStatus(`Sende ${percent}% (${humanReadableSize(sent)} / ${humanReadableSize(bytes.length)})`);
          }
          await delay(4);
        }

        if (remoteError) throw new Error(remoteError);

        try {
          await writeBle(control, textEncoder.encode('END'));
        } catch (err) {
          throw new Error('END schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        setBleStatus('Übertragung gesendet, warte auf Bestätigung …');
        await waitFor(() => remoteDone || remoteError, 3000);
        if (remoteError) throw new Error(remoteError);
        if (!remoteDone) {
          setBleStatus('Bild übertragen – Brosche sollte das Bild anzeigen.');
        }
      } catch (error) {
        console.error(error);
        const message = error?.message || error?.toString() || 'Unbekannter Fehler';
        setBleStatus(`Fehler: ${message}`);
        alert('Fehler beim BLE-Senden: ' + message);
      } finally {
        try {
          if (control && notifyHandler) {
            control.removeEventListener('characteristicvaluechanged', notifyHandler);
            await control.stopNotifications();
          }
        } catch (_) { /* noop */ }
        try {
          if (server?.connected) {
            server.disconnect();
          }
        } catch (_) { /* noop */ }
        bleSending = false;
        updateActionButtons();
      }
    }

    async function fetchUsbLogManually() {
      if (!usbSupported) {
        alert('WebSerial wird von diesem Browser nicht unterstützt. Bitte Chrome oder Edge auf dem Desktop verwenden.');
        return;
      }
      if (usbSending || bleSending) return;

      let port = null;
      let writer = null;
      let reader = null;
      let readableClosed = null;
      let lineReader = null;

      try {
        usbSending = true;
        updateActionButtons();
        setUsbStatus('USB-Log wird angefordert …');

        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200, dataBits: 8, stopBits: 1, parity: 'none', flowControl: 'none' });

        if (typeof port.setSignals === 'function') {
          usbLog('<>', 'setSignals übersprungen (log fetch)');
        }

        await delay(200);

        if (!port.writable || !port.readable) {
          throw new Error('Port bietet keine Lese-/Schreibstreams.');
        }

        const decoder = new TextDecoderStream();
        readableClosed = port.readable.pipeTo(decoder.writable).catch(() => {});
        reader = decoder.readable.getReader();
        lineReader = createLineReader(reader);
        writer = port.writable.getWriter();

        const entries = await dumpDeviceLog(lineReader, writer, 24);
        const text = entries.map((line, idx) => `${idx + 1}. ${line || '(leer)'}`).join('\n');
        if (text) {
          console.log('[USB LOG FETCH]\n' + text);
          setUsbStatus(`USB-Log erhalten (${entries.length} Einträge).`);
          showUsbErrorDialog(`USB-Log (${entries.length} Einträge):\n\n${text}`);
        } else {
          setUsbStatus('USB-Log: Keine Einträge verfügbar.');
          showUsbErrorDialog('USB-Log: Keine Einträge verfügbar.');
        }
      } catch (error) {
        console.error(error);
        const message = error?.message || error?.toString() || 'Unbekannter Fehler';
        setUsbStatus(`USB-Log abrufen fehlgeschlagen: ${message}`);
        await alertUsbError('USB-Log abrufen fehlgeschlagen: ' + message);
      } finally {
        try {
          if (writer) {
            await writer.releaseLock();
          }
        } catch (_) { /* noop */ }
        try {
          if (reader) {
            await reader.cancel();
          }
        } catch (_) { /* noop */ }
        try {
          if (readableClosed) {
            await readableClosed.catch(() => {});
          }
        } catch (_) { /* noop */ }
        try {
          if (port) {
            await port.close();
          }
        } catch (_) { /* noop */ }
        usbSending = false;
        updateActionButtons();
      }
    }

    function hasFilePayload(evt) {
      const dt = evt?.dataTransfer;
      if (!dt) return false;
      if (dt.types) {
        if (typeof dt.types.includes === 'function' && dt.types.includes('Files')) return true;
        if (typeof dt.types.contains === 'function' && dt.types.contains('Files')) return true;
      }
      return !!(dt.files && dt.files.length);
    }

    function extractFileFromDataTransfer(dt) {
      if (!dt) return null;
      if (dt.files && dt.files.length) return dt.files[0];
      if (dt.items) {
        for (const item of dt.items) {
          if (item.kind === 'file') {
            const file = item.getAsFile();
            if (file) return file;
          }
        }
      }
      return null;
    }

    function buildDownloadName(originalName) {
      const raw = typeof originalName === 'string' ? originalName : '';
      const normalized = raw.split(/[\\/]/).pop() || '';
      const idx = normalized.lastIndexOf('.');
      const base = idx > 0 ? normalized.slice(0, idx) : (normalized || 'image');
      return `${base}_240.jpg`;
    }

    function setDropActive(active) {
      document.body.classList.toggle('drop-active', active);
    }

    async function initMozIfNeeded() {
      if (moz) {
        mozReady = true;
        return true;
      }
      try {
        moz = await moduleFactory(); // lädt automatisch mozjpeg_enc.wasm
        console.log('MozJPEG (WASM) bereit.');
        mozReady = true;
        updateActionButtons();
        return true;
      } catch (err) {
        console.error(err);
        alert('Konnte MozJPEG-WASM nicht laden. Prüfe Internetverbindung oder nutze lokale Dateien in ./mozjpeg/');
        return false;
      }
    }

    async function setBitmapFromFile(file) {
      if (!file) return;
      if (file.type && !file.type.startsWith('image/')) {
        alert('Bitte eine Bilddatei auswählen oder ablegen.');
        return;
      }
      try {
        currentBitmap = await loadImageBitmap(file);
      } catch (err) {
        console.error(err);
        alert('Konnte die Bilddatei nicht laden. Versuche es bitte mit einer anderen Datei.');
        return;
      }
      const displayName = file.name ? file.name.split(/[\\/]/).pop() : '';
      currentDownloadName = buildDownloadName(displayName);
      resetCoverPan();
      drawScaled(currentBitmap);
      updateCanvasCursor();
      fileInput.value = '';
      await initMozIfNeeded();
      updateActionButtons();
      if (!bleSending) {
        setBleStatus('');
      }
      if (!usbSending) {
        setUsbStatus('');
      }
    }

    // JPEG header scan to verify non-progressive:
    // Baseline SOF0 marker = 0xFFC0, Progressive SOF2 = 0xFFC2
    function isProgressiveJPEG(u8) {
      for (let i = 0; i < u8.length - 1; i++) {
        if (u8[i] === 0xFF) {
          const code = u8[i + 1];
          if (code === 0xC2) return true;   // SOF2
          if (code === 0xDA) break;         // SOS reached -> stop scanning
        }
      }
      return false;
    }

    function clearCanvas() {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, cv.width, cv.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, cv.width, cv.height);
      ctx.restore();
    }

    function resetCoverPan() {
      coverPan.x = 0;
      coverPan.y = 0;
    }

    async function loadImageBitmap(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      await img.decode();
      const bmp = await createImageBitmap(img);
      URL.revokeObjectURL(url);
      return bmp;
    }

    function clampCoverPanValues(bmp, x, y) {
      if (!bmp) return { x: 0, y: 0 };
      const T = 240;
      const s = Math.max(T / bmp.width, T / bmp.height);
      const w = bmp.width * s;
      const h = bmp.height * s;
      const maxPanX = Math.max(0, (w - T) / 2);
      const maxPanY = Math.max(0, (h - T) / 2);
      return {
        x: Math.max(-maxPanX, Math.min(maxPanX, x)),
        y: Math.max(-maxPanY, Math.min(maxPanY, y))
      };
    }

    function updateCanvasCursor() {
      if (currentBitmap && modeSel.value === 'cover') {
        cv.style.cursor = isDragging ? 'grabbing' : 'grab';
      } else {
        cv.style.cursor = 'default';
      }
    }

    function drawScaled(bmp) {
      clearCanvas();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const T = 240, sw = bmp.width, sh = bmp.height;
      if (modeSel.value === 'cover') {
        const s = Math.max(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const clamped = clampCoverPanValues(bmp, coverPan.x, coverPan.y);
        coverPan.x = clamped.x;
        coverPan.y = clamped.y;
        const dx = (T - w) / 2 + coverPan.x;
        const dy = (T - h) / 2 + coverPan.y;
        ctx.drawImage(bmp, dx, dy, w, h);
      } else {
        const s = Math.min(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const dx = (T - w) / 2, dy = (T - h) / 2;
        ctx.drawImage(bmp, dx, dy, w, h);
      }
    }

    document.documentElement.addEventListener('dragenter', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (dropDepth++ === 0) {
        setDropActive(true);
      }
    });

    document.documentElement.addEventListener('dragover', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'copy';
      }
    });

    document.documentElement.addEventListener('dragleave', () => {
      if (dropDepth > 0) dropDepth--;
      if (dropDepth === 0) {
        setDropActive(false);
      }
    });

    document.documentElement.addEventListener('drop', async (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      dropDepth = 0;
      setDropActive(false);
      const file = extractFileFromDataTransfer(e.dataTransfer);
      await setBitmapFromFile(file);
    });

    window.addEventListener('blur', () => {
      dropDepth = 0;
      setDropActive(false);
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      await setBitmapFromFile(file);
    });

    modeSel.addEventListener('change', () => {
      if (isDragging) {
        isDragging = false;
      }
      updateCanvasCursor();
      if (currentBitmap) drawScaled(currentBitmap);
    });

    cv.addEventListener('pointerdown', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      e.preventDefault();
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      panStart = { x: coverPan.x, y: coverPan.y };
      try {
        cv.setPointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    });

    cv.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      const nextPan = clampCoverPanValues(currentBitmap, panStart.x + dx, panStart.y + dy);
      coverPan.x = nextPan.x;
      coverPan.y = nextPan.y;
      drawScaled(currentBitmap);
    });

    function endDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      try {
        cv.releasePointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    }

    cv.addEventListener('pointerup', endDrag);
    cv.addEventListener('pointercancel', endDrag);

    btnSave.addEventListener('click', async () => {
      if (bleSending || usbSending) return;
      btnSave.disabled = true;
      try {
        const { bytes, filename } = await encodeCurrentImage();
        const blob = new Blob([bytes], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename || 'image_240.jpg';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
      } finally {
        updateActionButtons();
      }
    });

    if (btnUsb) {
      btnUsb.addEventListener('click', sendViaUsb);
      if (!secureContext) {
        btnUsb.title = 'WebSerial benötigt HTTPS oder localhost.';
        setUsbStatus('WebSerial benötigt eine sichere Herkunft. Bitte die Seite über https:// oder http://localhost ausliefern (z. B. \"python -m http.server\" nutzen) und dann erneut versuchen.');
      } else if (!serialAvailable) {
        btnUsb.title = 'WebSerial wird von diesem Browser nicht freigegeben.';
        setUsbStatus('WebSerial wird von diesem Browser/Profil nicht unterstützt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge auf dem Desktop.');
      }
    }

    if (btnUsbLog) {
      btnUsbLog.addEventListener('click', fetchUsbLogManually);
      if (!secureContext) {
        btnUsbLog.title = 'WebSerial benötigt HTTPS oder localhost.';
      } else if (!serialAvailable) {
        btnUsbLog.title = 'WebSerial wird von diesem Browser nicht freigegeben.';
      }
    }

    btnBle.addEventListener('click', sendViaBle);

    if (!secureContext) {
      btnBle.title = 'WebBluetooth benötigt HTTPS oder localhost.';
      setBleStatus('WebBluetooth benötigt eine sichere Herkunft. Bitte die Seite über https:// oder http://localhost ausliefern (z. B. "python -m http.server" nutzen) und dann erneut versuchen.');
    } else if (!bleAvailable) {
      btnBle.title = 'WebBluetooth wird von diesem Browser nicht freigegeben.';
      setBleStatus('WebBluetooth wird von diesem Browser/Profil nicht unterstützt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge.');
    }

    ensureManualPortTools();
    updateActionButtons();
  </script>
</body>
</html>

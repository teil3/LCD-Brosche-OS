<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bildaufbereiter | Pixel Pin</title>
  <link rel="stylesheet" href="../shared-styles.css">
  <style>
    :root { color-scheme: dark; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 880px; margin: 2rem auto; padding: 0 1rem; background: #000000; color: #ffffff; }
    header { margin-bottom: 2rem; display: flex; align-items: flex-start; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap; }
    .header__text { flex: 1 1 320px; min-width: 0; }
    .header__logo { display: block; flex: 0 0 auto; width: 160px; margin-left: auto; order: 0; }
    .header__logo img { display: block; width: 100%; max-width: 100%; height: auto; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
    @media (max-width: 680px) {
      header { flex-direction: column; align-items: center; text-align: center; }
      .header__text { flex: 1 1 auto; }
      .header__logo { order: -1; margin-left: 0; margin-bottom: .75rem; }
    }
    h1 { font-size: clamp(1.8rem, 3vw, 2.5rem); margin: 0 0 .5rem; color: #ff6600; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
    .subtitle { font-size: 1em; color: #cccccc; margin-bottom: 1rem; }
    .muted { opacity: .75; color: #888888; }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; margin: .75rem 0; }
    .preview { position: relative; display: block; width: 270px; height: 262.5px; margin: 2.5rem auto 0; }
    .preview__viewport { position: absolute; top: 32.8px; left: 41.3px; width: 180px; height: 180px; border-radius: 50%; overflow: hidden; border: 1px solid #c9c9c9; box-shadow: 0 1px 8px rgba(0,0,0,.08); background: #fff; }
    .preview__viewport::after { content: ""; position: absolute; inset: 0; border-radius: 50%; pointer-events: none; box-shadow: inset 0 0 0 1px rgba(0,0,0,.12); }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: default; }
    .preview__mask { position: absolute; top: 0px; left: 0px; right: 0; bottom: 0; width: 100%; height: 100%; pointer-events: none; object-fit: cover; }
    .preview__control { position: absolute; bottom: 8px; left: 228px; font-size: .85rem; cursor: pointer; display: flex; align-items: center; gap: .4rem; white-space: nowrap; }
    .preview__control input[type="checkbox"] { cursor: pointer; margin: 0; }
    button, select, input[type="number"], input[type="file"], input[type="color"] { padding: .55rem .8rem; border-radius: .6rem; border: 1px solid rgba(255, 102, 0, 0.3); background: rgba(255, 255, 255, 0.1); color: #ffffff; }
    button { background: #ff6600; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; border: none; }
    button:hover:not([disabled]) { background: #ff8833; transform: scale(1.05); box-shadow: 0 5px 15px rgba(255, 102, 0, 0.4); }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    .actions { margin: 1.5rem 0 0; }
    footer { margin-top: 2rem; font-size: .9rem; }
    code { background: rgba(127,127,127,.15); padding: .1rem .3rem; border-radius: .3rem; }
    .drop-overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; padding: 2rem; color: #ff6600; font-weight: 600; font-size: clamp(1.1rem, 2.5vw, 1.6rem); background: rgba(255, 102, 0, .14); border: 2px dashed rgba(255, 102, 0, .6); pointer-events: none; opacity: 0; transform: scale(1.02); transition: opacity .2s ease, transform .2s ease; z-index: 999; }
    body.drop-active .drop-overlay { opacity: 1; transform: scale(1); }
    body.drop-active .preview__viewport { border-color: #ff6600; box-shadow: 0 0 0 4px rgba(255, 102, 0, .25); }
    .drop-hint { margin: -.25rem 0 0; font-size: .9rem; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
    .file-picker { display: flex; align-items: center; gap: .6rem; flex-wrap: wrap; }
    .file-picker__button { display: inline-flex; align-items: center; justify-content: center; padding: .55rem .9rem; border-radius: .6rem; border: none; background: #ff6600; color: white; cursor: pointer; font-weight: bold; transition: all 0.3s ease; }
    .file-picker__button:hover { background: #ff8833; transform: scale(1.05); }
    .file-picker__button:focus-visible { outline: 2px solid #ff6600; outline-offset: 2px; }
    .version-tag { font-weight: 400; font-size: .72rem; opacity: .6; margin-left: .5rem; }
    .error-modal { position: fixed; inset: 0; background: rgba(0,0,0,.75); display: none; align-items: center; justify-content: center; padding: 1.5rem; z-index: 1500; }
    .error-modal.open { display: flex; }
    .error-modal__box { background: rgba(255, 255, 255, 0.05); color: #ffffff; border: 1px solid rgba(255, 102, 0, 0.3); backdrop-filter: blur(10px); border-radius: .9rem; box-shadow: 0 20px 45px rgba(0,0,0,.5); max-width: min(720px, 95vw); width: 100%; padding: 1.4rem; display: flex; flex-direction: column; gap: 1rem; }
    .error-modal__title { margin: 0; font-size: 1.1rem; font-weight: 600; color: #ff6600; }
    .error-modal__textarea { width: 100%; min-height: 220px; font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .9rem; line-height: 1.35; border-radius: .6rem; border: 1px solid rgba(255, 102, 0, 0.3); background: rgba(0, 0, 0, 0.3); color: #ffffff; padding: .75rem; resize: vertical; box-sizing: border-box; }
    .error-modal__textarea:focus-visible { outline: 2px solid #ff6600; outline-offset: 2px; }
    .error-modal__actions { display: flex; justify-content: flex-end; gap: .75rem; }
  </style>
</head>
<body>
  <div class="drop-overlay" aria-hidden="true">Bilddatei hier ablegen, um sie zu laden</div>
  <header>
    <div class="header__text">
      <h1>Bildaufbereiter <span class="version-tag" id="tool-version"></span></h1>
      <p class="subtitle">Mit dieser Anwendung kannst du deine Bilder so vorbereiten, dass sie perfekt auf dem Pixel Pin angezeigt werden. Du kannst sie anschliessend per Bluetooth, USB oder √ºber eine SD-Karte √ºbertragen. </p>
      <p class="muted" style="font-size: .85rem;">
        <a href="../../#webtools" style="color: #ff6600; text-decoration: none;">‚Üê Zur√ºck zur Dokumentation</a>
      </p>
      <p><b>Wichtig: <a href="#usb-ble-transfer">Pixel Pin zuerst in Empfangsmodus versetzen!</a><b/></p>
    </div>
    <a class="header__logo" href="../../index.html">
      <img src="../../assets/logo.png" alt="Pixel Pin Logo" />
    </a>
  </header>

  <div class="row">
    <div class="file-picker">
      <label class="file-picker__button" for="file">Bild ausw√§hlen‚Ä¶</label>
      <input id="file" type="file" accept="image/*" class="visually-hidden" />
    </div>
    <label>Zuschnitt:
      <select id="mode">
        <option value="cover">Zentriert zuschneiden (f√ºllend)</option>
        <option value="contain">Einpassen (farbig auff√ºllen)</option>
      </select>
    </label>
    <label>Hintergrundfarbe:
      <input id="bgcolor" type="color" value="#ffffff" title="Hintergrundfarbe f√ºr 'Einpassen' Modus">
    </label>
    <label>Qualit√§t:
      <input id="quality" type="number" min="10" max="100" value="92" style="width:5rem"> %
    </label>
  </div>
  <p class="muted drop-hint">Tipp: Ziehe eine Bilddatei irgendwo auf diese Seite ‚Äì sie wird automatisch geladen.</p>

  <div class="preview">
    <div class="preview__viewport">
      <canvas id="cv" width="240" height="240"></canvas>
    </div>
    <img class="preview__mask" src="./LCD-Brosche-maske_dark.png" alt="Maske der LCD-Brosche" />
    <label class="preview__control">
      <input id="pixelperfect" type="checkbox" checked title="Bildgl√§ttung bei starker Vergr√∂√üerung">
      Vergr√∂sserung weichzeichnen
    </label>
  </div>

  <div class="actions">
    <button id="save" disabled>Als JPEG speichern</button>
    <button id="send-usb" disabled>√úber USB senden</button>
    <!-- <button id="send-usb-log" disabled>USB-Log abrufen</button> -->
    <button id="send-ble" disabled>Per Bluetooth senden</button>
    <p id="usb-status" class="muted" aria-live="polite"></p>
    <p id="ble-status" class="muted" aria-live="polite"></p>
    <p id="debug-status" style="font-family: monospace; font-size: 0.85em; color: #888; margin-top: 10px; white-space: pre-wrap;"></p>
    <div style="margin-left: 20px; margin-top: 15px;" id="usb-ble-transfer">
      <h3 style="font-size: 1.1em; color: #ff8833;">üì° USB/BLE-Transfer aktivieren</h3>
      <ul class="feature-list" style="margin-top: 5px;">
        <li>Button1 Doppelklick: Setup-Men√º √∂ffnen </li>
        <li>Button 2 Einfachklick: Zum Men√ºpunkt "USB/BLE-Transfer" wechseln</li>
        <li>Button 2 Langklick: "USB/BLE-Transfer" ausw√§hlen</li>
        <li>Nach Auswahl √∂ffnet sich der Transfer-Bildschirm</li>
        <li>√úbertragung kann per BLE (Bluetooth) oder USB Serial erfolgen</li>
        <li>Fortschrittsanzeige w√§hrend der √úbertragung</li>
        <li><strong>Langklick:</strong> Transfer abbrechen und zur√ºck zum Setup-Men√º</li>
        <li><strong>Doppelklick:</strong> Transfer beenden und Men√º schlie√üen</li>
      </ul>
    </div>
  </div>

  <footer style="text-align: center; padding: 30px 20px; color: #888; margin-top: 40px; border-top: 1px solid rgba(255, 102, 0, 0.2);">
<!--     <p class="muted" style="font-size: .85rem; margin-bottom: 15px;">MozJPEG Encoder: <span id="mozjpeg-source">wird geladen...</span></p> -->
    <p class="footer-project" style="margin-bottom: 10px; font-size: 0.9em;">Ein Projekt von:</p>
    <a href="https://www.teil3.ch" target="_blank" rel="noopener" class="footer-logo" style="display: inline-block; opacity: 0.6; transition: opacity 0.3s ease;">
      <img src="../teil3_logo.svg" alt="Teil3" style="height: 40px; width: auto;" />
    </a>
  </footer>

  <script type="module">
    // --- Import der MozJPEG-WASM-Codec-Factory (jSquash) ---
    // Dokumentation/Quelle: https://github.com/jamsinclair/jSquash (encode API)
    // Strategie:
    // - Bei http/https: Prim√§r lokale Dateien aus ./mozjpeg/ (offline-f√§hig), Fallback CDN
    // - Bei file://: Nur CDN (ES6 Module k√∂nnen nicht lokal via file:// geladen werden)
    let moduleFactory = null;
    let mozModuleSource = 'unknown';
    const mozModuleErrors = [];
    const isFileProtocol = location.protocol === 'file:';

    if (isFileProtocol) {
      // file:// - nur CDN m√∂glich (CORS-Einschr√§nkung f√ºr ES6 Module)
      console.info('[MozJPEG] file:// erkannt - verwende CDN (lokale ES6 Module via file:// nicht m√∂glich).');
      try {
        moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;
        mozModuleSource = 'cdn';
        console.info('[MozJPEG] Encoder via CDN geladen (unpkg.com).');
      } catch (cdnError) {
        mozModuleErrors.push(cdnError);
        console.error('[MozJPEG] CDN-Import fehlgeschlagen.', cdnError);
      }
    } else {
      // http/https - lokale Dateien bevorzugt, CDN als Fallback
      try {
        moduleFactory = (await import('./mozjpeg/mozjpeg_enc.js?module')).default;
        mozModuleSource = 'local';
        console.info('[MozJPEG] Encoder aus ./mozjpeg/ geladen (lokal).');
      } catch (localError) {
        mozModuleErrors.push(localError);
        console.warn('[MozJPEG] Lokaler Import fehlgeschlagen, versuche CDN-Fallback ‚Ä¶', localError);
        try {
          moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;
          mozModuleSource = 'cdn';
          console.info('[MozJPEG] Encoder via CDN geladen (unpkg.com).');
        } catch (cdnError) {
          mozModuleErrors.push(cdnError);
          console.error('[MozJPEG] CDN-Fallback fehlgeschlagen.', cdnError);
        }
      }
    }

    if (!moduleFactory) {
      const combinedError = mozModuleErrors.pop() || new Error('Unbekannter Importfehler');
      const message = isFileProtocol
        ? 'MozJPEG-WASM konnte nicht geladen werden. Bei file:// ist eine Internetverbindung erforderlich. Alternativ: Mit lokalem HTTP-Server √∂ffnen (z.B. "python3 -m http.server").'
        : 'MozJPEG-WASM konnte nicht geladen werden. Bitte ./mozjpeg/ bereitstellen oder Internetverbindung pr√ºfen.';
      console.error(message, { mozModuleErrors });
      alert(message);
      throw combinedError;
    }
    window.__mozjpegSource = mozModuleSource;
    const TOOL_VERSION = 'V0.16';

    const fileInput = document.getElementById('file');
    const modeSel   = document.getElementById('mode');
    const bgColorInput = document.getElementById('bgcolor');
    const pixelPerfectInput = document.getElementById('pixelperfect');
    const qInput    = document.getElementById('quality');
    const btnSave   = document.getElementById('save');
    const btnUsb    = document.getElementById('send-usb');
    // const btnUsbLog = document.getElementById('send-usb-log');
    const btnBle    = document.getElementById('send-ble');
    const versionLabel = document.getElementById('tool-version');
    const mozjpegSourceLabel = document.getElementById('mozjpeg-source');
    const usbStatus = document.getElementById('usb-status');
    const bleStatus = document.getElementById('ble-status');
    const debugStatus = document.getElementById('debug-status');
    const cv        = document.getElementById('cv');
    const ctx       = cv.getContext('2d', { willReadFrequently: true });
    const BLE_UUIDS = {
      service: '12345678-1234-1234-1234-1234567890ab',
      chunk:   'abcd0001-1234-1234-1234-1234567890ab',
      control: 'abcd0002-1234-1234-1234-1234567890ab'
    };
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    let currentBitmap = null;
    let moz = null;
    let mozReady = false;
    let coverPan = { x: 0, y: 0 };
    let zoomScale = 1.0;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };
    let dropDepth = 0;
    let touchStartDistance = 0;
    let touchStartZoom = 1.0;
    let touchCenter = { x: 0, y: 0 };
    let currentDownloadName = 'image.jpg';
    let bleSending = false;
    let usbSending = false;
    const usbDebugLog = [];
    let usbErrorModal = null;
    let usbErrorModalText = null;
    let usbErrorModalCopyBtn = null;
    let usbErrorModalCloseBtn = null;
    let usbErrorModalKeyHandlerAttached = false;

    if (versionLabel) {
      versionLabel.textContent = TOOL_VERSION;
    }
    if (mozjpegSourceLabel) {
      const sourceText = mozModuleSource === 'local' ? 'Lokal (./mozjpeg/)' :
                         mozModuleSource === 'cdn' ? 'CDN (unpkg.com)' :
                         'unbekannt';
      mozjpegSourceLabel.textContent = sourceText;
    }

    const secureContextHosts = new Set(['localhost', '127.0.0.1', '::1']);
    const secureContext = window.isSecureContext || secureContextHosts.has(location.hostname);
    const bleAvailable = 'bluetooth' in navigator;
    const bleSupported = secureContext && bleAvailable;
    const serialAvailable = 'serial' in navigator;
    const usbSupported = secureContext && serialAvailable;

    function setUsbStatus(text) {
      if (!usbStatus) return;
      usbStatus.textContent = text || '';
    }

    function usbLog(direction, message) {
      const entry = `${direction} ${message}`;
      if (usbDebugLog.length >= 80) {
        usbDebugLog.shift();
      }
      usbDebugLog.push(entry);
      console.debug('[USB LOG]', entry);
    }

    function usbLogSnapshot() {
      return usbDebugLog.slice(-12).join('\n');
    }

    function ensureUsbErrorModal() {
      if (usbErrorModal) return usbErrorModal;
      const overlay = document.createElement('div');
      overlay.className = 'error-modal';

      const box = document.createElement('div');
      box.className = 'error-modal__box';

      const title = document.createElement('h2');
      title.className = 'error-modal__title';
      title.textContent = 'USB-Fehlerdetails';

      const textarea = document.createElement('textarea');
      textarea.className = 'error-modal__textarea';
      textarea.setAttribute('readonly', 'readonly');

      const actions = document.createElement('div');
      actions.className = 'error-modal__actions';

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.textContent = 'In Zwischenablage kopieren';

      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.textContent = 'Schliessen';

      actions.appendChild(copyBtn);
      actions.appendChild(closeBtn);
      box.appendChild(title);
      box.appendChild(textarea);
      box.appendChild(actions);
      overlay.appendChild(box);
      document.body.appendChild(overlay);

      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(textarea.value);
          copyBtn.textContent = 'Kopiert ‚úî';
          setTimeout(() => { copyBtn.textContent = 'In Zwischenablage kopieren'; }, 1600);
        } catch (err) {
          console.warn('Clipboard write failed', err);
        }
        textarea.focus();
        textarea.select();
      });

      closeBtn.addEventListener('click', () => {
        overlay.classList.remove('open');
      });

      overlay.addEventListener('click', (evt) => {
        if (evt.target === overlay) {
          overlay.classList.remove('open');
        }
      });

      if (!usbErrorModalKeyHandlerAttached) {
        document.addEventListener('keydown', (evt) => {
          if (evt.key === 'Escape' && overlay.classList.contains('open')) {
            overlay.classList.remove('open');
          }
        });
        usbErrorModalKeyHandlerAttached = true;
      }

      usbErrorModal = overlay;
      usbErrorModalText = textarea;
      usbErrorModalCopyBtn = copyBtn;
      usbErrorModalCloseBtn = closeBtn;
      return overlay;
    }

    function showUsbErrorDialog(message) {
      const overlay = ensureUsbErrorModal();
      if (!usbErrorModalText) return;
      usbErrorModalText.value = message;
      if (usbErrorModalCopyBtn) {
        usbErrorModalCopyBtn.textContent = 'In Zwischenablage kopieren';
      }
      requestAnimationFrame(() => {
        overlay.classList.add('open');
        usbErrorModalText.focus();
        usbErrorModalText.select();
      });
    }

    async function alertUsbError(message) {
      const log = usbLogSnapshot();
      const fullMessage = log ? `${message}\n\nLetzte USB-Meldungen:\n${log}` : message;
      console.error('USB ERROR:', message, { log: usbDebugLog.slice() });
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(fullMessage);
          usbLog('<>', 'Fehlerdetails in die Zwischenablage kopiert.');
        } catch (err) {
          usbLog('!!', `Clipboard write failed: ${err?.message || err}`);
        }
      }
      try {
        showUsbErrorDialog(fullMessage);
      } catch (err) {
        console.warn('Fallback alert (Dialog fehlgeschlagen)', err);
        alert(fullMessage);
      }
    }

    function setBleStatus(text) {
      if (!bleStatus) return;
      bleStatus.textContent = text || '';
    }

    const debugLog = [];
    function addDebugLog(msg) {
      const timestamp = new Date().toLocaleTimeString('de-DE');
      const entry = `[${timestamp}] ${msg}`;
      debugLog.push(entry);
      console.log(entry);
      if (debugLog.length > 10) {
        debugLog.shift();
      }
      if (debugStatus) {
        debugStatus.textContent = debugLog.join('\n');
      }
    }

    function updateActionButtons() {
      const ready = !!currentBitmap && mozReady;
      const busy = bleSending || usbSending;
      if (btnSave) btnSave.disabled = !ready || busy;
      if (btnUsb) btnUsb.disabled = !ready || !usbSupported || busy;
      // if (btnUsbLog) btnUsbLog.disabled = !usbSupported || busy;
      if (btnBle) btnBle.disabled = !ready || !bleSupported || busy;
    }

    function sanitizeFilenameForTransfer(name) {
      const fallback = 'ble_image.jpg';
      if (!name) return fallback;
      let base = name.split(/[\\/]/).pop() || fallback;
      base = base.toLowerCase();
      let out = '';
      for (const ch of base) {
        if ((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch === '-' || ch === '_' || ch === '.') {
          out += ch;
        } else if (ch === ' ') {
          out += '_';
        }
        if (out.length >= 60) break;
      }
      if (!out) out = fallback;
      if (out.startsWith('.')) out = out.substring(1) || fallback;
      if (!out.endsWith('.jpg') && !out.endsWith('.jpeg')) {
        out += '.jpg';
      }
      if (out.length > 60) {
        const idx = out.lastIndexOf('.');
        const ext = idx >= 0 ? out.slice(idx) : '.jpg';
        const stem = idx >= 0 ? out.slice(0, idx) : out;
        out = stem.slice(0, Math.max(1, 60 - ext.length)) + ext;
      }
      return out;
    }

    function humanReadableSize(bytes) {
      if (!Number.isFinite(bytes)) return '0 B';
      if (bytes < 1024) return `${bytes} B`;
      const kb = bytes / 1024;
      const rounded = Math.round(kb * 10) / 10;
      return `${rounded.toFixed(rounded % 1 === 0 ? 0 : 1)} KB`;
    }

    async function encodeCurrentImage() {
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild ausw√§hlen.');
        throw new Error('Kein Bild geladen');
      }
      const ready = await initMozIfNeeded();
      if (!ready || !moz) {
        throw new Error('JPEG-Codec nicht verf√ºgbar');
      }

      let imageData = null;
      try {
        imageData = ctx.getImageData(0, 0, cv.width, cv.height);
      } catch (err) {
        throw new Error('Canvas-Daten konnten nicht gelesen werden: ' + (err?.message || err));
      }

      const { data } = imageData;
      const quality = Math.min(100, Math.max(10, parseInt(qInput.value, 10) || 92));
      const opts = {
        quality,
        baseline: true,
        progressive: false,
        arithmetic: false,
        optimize_coding: true,
        smoothing: 0,
        color_space: 3,
        quant_table: 3,
        trellis_multipass: false,
        trellis_opt_zero: false,
        trellis_opt_table: false,
        trellis_loops: 1,
        auto_subsample: false,
        chroma_subsample: 2,
        separate_chroma_quality: false,
        chroma_quality: quality
      };

      let jpegU8;
      try {
        jpegU8 = moz.encode(data, 240, 240, opts);
      } catch (error) {
        console.error(error);
        alert('Fehler beim JPEG-Encode: ' + (error?.message || error));
        throw error;
      } finally {
        // ImageData explizit freigeben
        imageData = null;
      }

      if (isProgressiveJPEG(jpegU8)) {
        alert('Warnung: Der erzeugte JPEG scheint progressiv zu sein.');
      }

      return {
        bytes: jpegU8,
        filename: currentDownloadName || 'image.jpg'
      };
    }

    async function writeBle(characteristic, data) {
      await characteristic.writeValue(data);
    }

    async function waitFor(predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (performance.now() < deadline) {
        if (predicate()) return true;
        await delay(50);
      }
      return predicate();
    }

    function createLineReader(reader) {
      let buffer = '';
      return {
        async readLine(timeoutMs) {
          const deadline = (typeof timeoutMs === 'number')
            ? performance.now() + timeoutMs
            : null;
          while (true) {
            const newlineIdx = buffer.indexOf('\n');
            if (newlineIdx >= 0) {
              const line = buffer.slice(0, newlineIdx);
              buffer = buffer.slice(newlineIdx + 1);
              return line.replace(/\r$/, '');
            }

            const readPromise = reader.read();
            let result;
            if (deadline !== null) {
              const remaining = deadline - performance.now();
              if (remaining <= 0) {
                throw new Error('Timeout beim Lesen von Ger√§tedaten');
              }
              result = await Promise.race([
                readPromise,
                delay(Math.max(remaining, 0)).then(() => ({ timeout: true })),
              ]);
              if (result?.timeout) {
                throw new Error('Timeout beim Lesen von Ger√§tedaten');
              }
            } else {
              result = await readPromise;
            }

            if (result.done) {
              if (buffer.length > 0) {
                const line = buffer;
                buffer = '';
                return line.replace(/\r$/, '');
              }
              throw new Error('Verbindung geschlossen');
            }
            if (result.value) {
              buffer += result.value;
            }
          }
        }
      };
    }

    async function waitForUsbLine(lineReader, predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (true) {
        const remaining = deadline - performance.now();
        if (remaining <= 0) {
          throw new Error('Timeout beim Warten auf Antwort des Ger√§ts');
        }
        const line = (await lineReader.readLine(Math.max(remaining, 50))).trim();
        if (!line) continue;
        usbLog('<=', line);
        if (!line.startsWith('USB')) {
          continue;
        }
        const payload = line.slice(3).trimStart();
        if (payload.startsWith('ERR')) {
          const message = payload.substring(3).trim();
          throw new Error(message || 'Ger√§tefehler');
        }
        if (payload.startsWith('OK PROG')) {
          const parts = payload.split(/\s+/);
          if (parts.length >= 4) {
            const received = Number(parts[2]);
            const total = Number(parts[3]);
            if (Number.isFinite(received) && Number.isFinite(total) && total > 0) {
              const pct = Math.min(100, Math.round((received / total) * 100));
              setUsbStatus(`Ger√§t empf√§ngt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          }
          continue;
        }
        if (payload.startsWith('OK MSG')) {
          const msg = payload.substring(6).trim();
          if (msg) setUsbStatus(msg);
          continue;
        }
        if (predicate(payload)) {
          return payload;
        }
      }
    }

    async function dumpDeviceLog(lineReader, writer, maxEntries = 16) {
      if (!writer || !lineReader) return [];
      try {
        usbLog('->', 'LOG');
        await writer.write(textEncoder.encode('LOG\n'));
      } catch (err) {
        usbLog('!!', `LOG senden fehlgeschlagen: ${err?.message || err}`);
        return [];
      }

      let ack;
      try {
        ack = await waitForUsbLine(
          lineReader,
          (payload) => payload.startsWith('OK LOG') || payload.startsWith('ERR'),
          2000
        );
      } catch (err) {
        usbLog('!!', `LOG-Antwort ausstehend: ${err?.message || err}`);
        return [];
      }

      if (ack.startsWith('ERR')) {
        usbLog('!!', `Ger√§t meldet LOG-Fehler: ${ack}`);
        return [];
      }

      const parts = ack.split(/\s+/);
      let count = Number(parts[2]);
      if (!Number.isFinite(count) || count <= 0) {
        count = maxEntries;
      }
      const limit = Math.min(count, Math.max(1, maxEntries));
      const entries = [];
      let guard = 0;

      while (entries.length < limit && guard < limit + 8) {
        guard += 1;
        try {
          const raw = (await lineReader.readLine(800)).trim();
          if (!raw) continue;
          usbLog('<=', raw);
          if (raw.startsWith('USB LOG')) {
            entries.push(raw.substring(7).trim());
          }
        } catch (err) {
          if (entries.length === 0) {
            usbLog('!!', `LOG lesen fehlgeschlagen: ${err?.message || err}`);
          } else {
            usbLog('<>', 'LOG lesen beendet (Timeout)');
          }
          break;
        }
      }

      if (!entries.length) {
        usbLog('<>', 'Keine LOG-Eintr√§ge vom Ger√§t erhalten.');
      }
      return entries;
    }

    async function sendViaUsb() {
      if (!usbSupported) {
        alert('WebSerial wird von diesem Browser nicht unterst√ºtzt. Bitte Chrome oder Edge auf dem Desktop verwenden.');
        return;
      }
      if (usbSending || bleSending) return;
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild ausw√§hlen.');
        return;
      }

      usbDebugLog.length = 0;

      let port = null;
      let writer = null;
      let reader = null;
      let readableClosed = null;
      let lineReader = null;
      let transferCompleted = false;

      try {
        usbSending = true;
        updateActionButtons();
        setUsbStatus('Bild wird vorbereitet ‚Ä¶');
        usbLog('<>', 'Beginne USB-Transfer');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);
        const totalSize = bytes.length;
        const totalLabel = humanReadableSize(totalSize);

        setUsbStatus('Seriellen Port ausw√§hlen ‚Ä¶');
        port = await navigator.serial.requestPort();

        // CRITICAL FIX: Simulate "monitor trick" by opening, closing, and reopening the port
        // This resets the OS-level serial driver state, which is necessary for reliable communication
        // Without this, the Web Serial API often fails to establish proper communication
        usbLog('<>', 'Performing port reset cycle (simulating monitor trick)...');
        try {
          await port.open({ baudRate: 115200 });
          await delay(100);
          await port.close();
          usbLog('<>', 'Port reset: closed');
          await delay(200);
        } catch (err) {
          usbLog('!!', `Port reset cycle failed (non-critical): ${err?.message || err}`);
        }

        // Now open the port for real
        try {
          await port.open({ baudRate: 115200 });
        } catch (err) {
          usbLog('!!', `open failed: ${err?.message || err}`);
          throw err;
        }

        usbLog('<>', 'Port opened after reset cycle');

        // Short delay to let the connection settle
        await delay(300);

        if (!port.writable) {
          throw new Error('Port bietet keinen Schreibstream.');
        }
        if (!port.readable) {
          throw new Error('Port bietet keinen Lesestream.');
        }

        if (typeof TextDecoderStream === 'undefined') {
          throw new Error('TextDecoderStream wird nicht unterst√ºtzt. Bitte einen aktuellen Chromium-Browser verwenden.');
        }
        const decoder = new TextDecoderStream();
        readableClosed = port.readable.pipeTo(decoder.writable).catch(() => {});
        reader = decoder.readable.getReader();
        lineReader = createLineReader(reader);

        writer = port.writable.getWriter();

        // Vorab Verbindung pr√ºfen (PING). Mit Retry-Mechanismus f√ºr den Fall,
        // dass der Benutzer zu schnell nach Aktivierung des Transfer-Modus klickt.
        usbLog('<>', 'Pr√ºfe Verbindung mit PING‚Ä¶');
        await delay(100);

        const maxPingRetries = 5;
        let pingSuccess = false;
        let lastPingError = null;

        for (let attempt = 1; attempt <= maxPingRetries; attempt++) {
          try {
            if (attempt > 1) {
              setUsbStatus(`Warte auf Transfer-Modus... (Versuch ${attempt}/${maxPingRetries})`);
              usbLog('<>', `PING retry attempt ${attempt}/${maxPingRetries}`);
              await delay(1000); // 1 Sekunde zwischen Retries
            }

            usbLog('->', 'PING');
            await writer.write(textEncoder.encode('PING\n'));

            const pong = await waitForUsbLine(
              lineReader,
              (payload) => payload.startsWith('OK PONG') || payload.startsWith('ERR'),
              3000
            );

            if (pong.startsWith('ERR')) {
              usbLog('!!', `Ger√§t meldet Fehler auf PING: ${pong}`);
              throw new Error('Ger√§t meldet Fehler');
            }

            usbLog('<=', pong);
            setUsbStatus('Ger√§t antwortet ‚Äì √úbertragung wird vorbereitet ‚Ä¶');
            pingSuccess = true;
            break;

          } catch (err) {
            lastPingError = err;
            usbLog('!!', `PING Versuch ${attempt} fehlgeschlagen: ${err?.message || err}`);
            // Continue to next retry
          }
        }

        if (!pingSuccess) {
          usbLog('!!', `Alle ${maxPingRetries} PING-Versuche fehlgeschlagen`);
          throw new Error(`Transfer-Modus nicht aktiv. Bitte BTN2 lang halten bis "TRANSFER" angezeigt wird, dann erneut versuchen.`);
        }

        const startLine = `START ${totalSize} ${sanitizedName}\n`;
        usbLog('->', startLine.trim());
        await writer.write(textEncoder.encode(startLine));

        let startAck = null;
        try {
          startAck = await waitForUsbLine(
            lineReader,
            // Wir ziehen die relevanten USB-Zeilen heraus und lassen Debug-Text ignorieren.
            (payload) => payload.startsWith('OK READY') ||
                         payload.startsWith('OK START') ||
                         payload.startsWith('ERR'),
            6000
          );
        } catch (err) {
          usbLog('!!', `Keine START-Best√§tigung innerhalb 6s: ${err?.message || err}`);
        }

        if (startAck) {
          usbLog('<=', startAck);
          if (startAck.startsWith('OK READY')) {
            usbLog('<>', 'READY best√§tigt ‚Äì warte auf OK START');
            try {
              startAck = await waitForUsbLine(
                lineReader,
                (payload) => payload.startsWith('OK START') || payload.startsWith('ERR'),
                6000
              );
              usbLog('<=', startAck);
            } catch (err) {
              usbLog('!!', `Kein OK START nach READY: ${err?.message || err}`);
            }
          }
        }

        if (startAck && startAck.startsWith('OK START')) {
          let deviceFilename = sanitizedName;
          const parts = startAck.split(/\s+/);
          if (parts.length >= 3) {
            deviceFilename = parts[2];
          }
          setUsbStatus(`√úbertragung gestartet (${deviceFilename})`);
          usbLog('<>', `Transfer best√§tigt: ${deviceFilename}`);
        } else if (startAck && startAck.startsWith('ERR')) {
          usbLog('!!', `Ger√§t meldet Fehler vor Datenstart: ${startAck}`);
          setUsbStatus(`Ger√§tefehler: ${startAck}`);
          throw new Error(startAck);
        } else {
          const noAckMsg = 'Keine START-Best√§tigung vom Ger√§t empfangen. Bitte sicherstellen, dass der Transfer-Modus aktiv ist (BTN2 lang halten, bis \"Transfer\" erscheint).';
          usbLog('!!', noAckMsg);
          setUsbStatus(noAckMsg);
          throw new Error(noAckMsg);
        }

        // With RAM buffering (ESP32 commit 549e054), there are NO PROG messages during transfer
        // The ESP32 buffers all data in RAM and only sends PROG after receiving END command
        // This matches the Python test script behavior (usb_transfer_test.py)

        let sent = 0;
        setUsbStatus(`Sende Daten (${totalLabel})...`);
        usbLog('->', `DATA all ${totalSize} bytes`);
        await writer.write(bytes);
        sent = totalSize;
        usbLog('<>', 'Host finished writing to port');

        // Wait for ESP32 to finish receiving the data
        // Calculate expected transfer time: (bytes * 10 bits/byte) / baudrate + margin
        // This matches the Python test script logic (usb_transfer_test.py lines 99-101)
        const expectedTransferTime = ((totalSize * 10) / 115200) * 1000; // in milliseconds
        const waitTime = Math.max(1000, expectedTransferTime + 1000); // minimum 1s, or expected time + 1s margin
        setUsbStatus(`Warte auf ESP32-Empfang (~${Math.round(waitTime/1000)}s)...`);
        usbLog('<>', `Waiting ${Math.round(waitTime/1000)}s for ESP32 to receive data (transfer time: ${Math.round(expectedTransferTime/1000)}s + 1s margin)`);
        await delay(waitTime);

        setUsbStatus('Sende END-Kommando...');
        usbLog('->', 'END');
        await writer.write(textEncoder.encode('END\n'));

        // After receiving END, ESP32 writes RAM buffer to Flash (can take time for large files)
        // Calculate flash write time: ~2ms per 512 byte chunk + overhead
        const flashWriteTime = Math.ceil((totalSize / 512) * 2) + 2000; // ms
        const endTimeout = Math.max(20000, flashWriteTime); // minimum 20s
        usbLog('<>', `Waiting for END response (timeout: ${Math.round(endTimeout/1000)}s, flash write estimate: ${Math.round(flashWriteTime/1000)}s)`);

        const endPredicate = (payload) => {
          if (payload.startsWith('OK END')) {
            return true;
          }
          if (payload.startsWith('OK PROG')) {
            const parts = payload.split(/\s+/);
            if (parts.length >= 4) {
              const received = Number(parts[2]);
              const total = Number(parts[3]);
              if (Number.isFinite(received) && Number.isFinite(total) && total > 0 && received >= total) {
                return true;
              }
            }
          }
          return false;
        };

        const endAck = await waitForUsbLine(lineReader, endPredicate, endTimeout);
        if (endAck.startsWith('OK PROG')) {
          setUsbStatus('√úbertragung abgeschlossen ‚úÖ (Best√§tigung √ºber Fortschrittsmeldung)');
        } else {
          const endParts = endAck.split(/\s+/);
          if (endParts.length >= 3) {
            setUsbStatus(`√úbertragung abgeschlossen ‚úÖ (${endParts[2]})`);
          } else {
            setUsbStatus('√úbertragung abgeschlossen ‚úÖ');
          }
        }
        transferCompleted = true;
        } catch (error) {
          console.error(error);
          const name = error?.name;
          let userMessage = '';
          let fetchLog = false;
          usbLog('<>', `HOST SENT ${sent}/${totalSize}`);

          if (name === 'NotFoundError') {
            setUsbStatus('USB-Senden abgebrochen ‚Äì kein Port ausgew√§hlt.');
            userMessage = 'USB-Senden abgebrochen ‚Äì kein Port ausgew√§hlt.';
          } else if (name === 'AbortError') {
            setUsbStatus('USB-Senden abgebrochen.');
            userMessage = 'USB-Senden abgebrochen.';
          } else if (name === 'NetworkError' || /device has been lost/i.test(error?.message || '')) {
            if (transferCompleted) {
              setUsbStatus('√úbertragung abgeschlossen ‚úÖ (Ger√§t hat den Port getrennt).');
              userMessage = '';
            } else {
              setUsbStatus('USB-Verbindung verloren ‚Äì bitte Brosche neu verbinden und Transfer-Modus erneut aktivieren.');
              userMessage = 'USB-Verbindung verloren. Bitte den ESP32 neu verbinden, Transfer-Modus (BTN2 lang) aktivieren und erneut senden.';
              fetchLog = true;
            }
          } else if (/timeout beim warten/i.test(error?.message || '')) {
            setUsbStatus('Timeout ‚Äì keine Antwort vom Ger√§t. Ist der Transfer-Modus aktiv (BTN2 lang in der Diashow)?');
            userMessage = 'Keine Antwort vom Ger√§t erhalten. Bitte sicherstellen, dass die Brosche im Transfer-Modus ist (BTN2 lang halten, bis "Transfer" angezeigt wird) und erneut versuchen.';
            fetchLog = true;
          } else {
            const message = error?.message || error?.toString() || 'Unbekannter Fehler';
            setUsbStatus(`Fehler: ${message}`);
            userMessage = 'Fehler beim USB-Senden: ' + message;
            fetchLog = true;
          }

          if (fetchLog && writer && lineReader) {
            try {
              await dumpDeviceLog(lineReader, writer, 20);
            } catch (logErr) {
              console.warn('Dump device log failed', logErr);
            }
          }

          if (userMessage) {
            await alertUsbError(userMessage);
          }
      } finally {
        try {
          if (writer) {
            usbLog('<>', 'release writer');
            await writer.releaseLock();
          }
        } catch (_) { /* ignore */ }
        try {
          if (reader) {
            usbLog('<>', 'cancel reader');
            await reader.cancel();
          }
        } catch (_) { /* ignore */ }
        try {
          if (readableClosed) {
            usbLog('<>', 'await readable close');
            await readableClosed.catch(() => {});
          }
        } catch (_) { /* ignore */ }
        try {
          if (port) {
            usbLog('<>', 'close port');
            await port.close();
          }
        } catch (_) { /* ignore */ }
        usbSending = false;
        updateActionButtons();
      }
    }

    async function sendViaBle() {
      if (!bleSupported) {
        alert('WebBluetooth wird von diesem Browser nicht unterst√ºtzt. Bitte Chrome, Edge oder Android Chrome verwenden.');
        return;
      }
      if (bleSending || usbSending) return;
      if (!currentBitmap) {
        alert('Bitte zuerst ein Bild ausw√§hlen.');
        return;
      }

      let device = null;
      let server = null;
      let control = null;
      let chunk = null;
      let notifyHandler = null;
      let startConfirmed = false;
      let remoteError = null;
      let remoteDone = false;

      try {
        bleSending = true;
        updateActionButtons();
        setBleStatus('Bild wird vorbereitet ‚Ä¶');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);

        setBleStatus('Bitte Brosche ausw√§hlen ‚Ä¶');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Brosche' }],
          optionalServices: [BLE_UUIDS.service]
        });
        device.addEventListener('gattserverdisconnected', () => {
          if (!remoteDone) {
            setBleStatus('BLE-Verbindung getrennt');
          }
        });

        setBleStatus('Verbindung wird hergestellt ‚Ä¶');
        server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_UUIDS.service);
        control = await service.getCharacteristic(BLE_UUIDS.control);
        chunk = await service.getCharacteristic(BLE_UUIDS.chunk);

        console.debug('BLE control props', control.properties);
        console.debug('BLE chunk props', chunk.properties);

        setBleStatus('Aktiviere Statusmeldungen ‚Ä¶');
        try {
          await control.startNotifications();
        } catch (err) {
          throw new Error('startNotifications fehlgeschlagen: ' + (err?.message || err));
        }

        notifyHandler = (event) => {
          const value = event.target.value;
          const text = textDecoder.decode(value);
          if (!text) return;
          console.log('[BLE] Status', text);
          if (text.startsWith('OK:START')) {
            startConfirmed = true;
            setBleStatus(`√úbertragung gestartet (${sanitizedName})`);
          } else if (text.startsWith('OK:PROG:')) {
            const parts = text.split(':');
            if (parts.length >= 4) {
              const received = Number(parts[2]) || 0;
              const total = Number(parts[3]) || 0;
              const pct = total ? Math.min(100, Math.round((received / total) * 100)) : 0;
              setBleStatus(`Brosche empf√§ngt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          } else if (text.startsWith('OK:END')) {
            remoteDone = true;
            setBleStatus('√úbertragung abgeschlossen.');
          } else if (text.startsWith('ERR:')) {
            remoteError = text.substring(4) || 'Unbekannter Fehler';
            setBleStatus(`Fehler vom Ger√§t: ${remoteError}`);
          }
        };
        control.addEventListener('characteristicvaluechanged', notifyHandler);

        const startPayload = `START:${bytes.length}:${sanitizedName}`;
        try {
          await writeBle(control, textEncoder.encode(startPayload));
        } catch (err) {
          throw new Error('START schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        const startOk = await waitFor(() => startConfirmed || remoteError, 2000);
        if (remoteError) throw new Error(remoteError);
        if (!startOk) {
          throw new Error('Keine R√ºckmeldung vom Ger√§t (BLE-Modus aktiv?).');
        }

        setBleStatus('Sende Bilddaten ‚Ä¶');
        const chunkSize = 20;
        for (let offset = 0; offset < bytes.length; offset += chunkSize) {
          const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
          try {
            await writeBle(chunk, slice);
          } catch (err) {
            throw new Error(`Chunk @${offset} (${slice.length} B) fehlgeschlagen: ${err?.message || err}`);
          }
          if (remoteError) break;
          if ((offset / chunkSize) % 24 === 0) {
            const sent = offset + slice.length;
            const percent = Math.min(100, Math.round((sent / bytes.length) * 100));
            setBleStatus(`Sende ${percent}% (${humanReadableSize(sent)} / ${humanReadableSize(bytes.length)})`);
          }
          await delay(4);
        }

        if (remoteError) throw new Error(remoteError);

        try {
          await writeBle(control, textEncoder.encode('END'));
        } catch (err) {
          throw new Error('END schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        setBleStatus('√úbertragung gesendet, warte auf Best√§tigung ‚Ä¶');
        await waitFor(() => remoteDone || remoteError, 3000);
        if (remoteError) throw new Error(remoteError);
        if (!remoteDone) {
          setBleStatus('Bild √ºbertragen ‚Äì Brosche sollte das Bild anzeigen.');
        }
      } catch (error) {
        console.error(error);
        const message = error?.message || error?.toString() || 'Unbekannter Fehler';
        setBleStatus(`Fehler: ${message}`);
        alert('Fehler beim BLE-Senden: ' + message);
      } finally {
        try {
          if (control && notifyHandler) {
            control.removeEventListener('characteristicvaluechanged', notifyHandler);
            await control.stopNotifications();
          }
        } catch (_) { /* noop */ }
        try {
          if (server?.connected) {
            server.disconnect();
          }
        } catch (_) { /* noop */ }
        bleSending = false;
        updateActionButtons();
      }
    }

    async function fetchUsbLogManually() {
      if (!usbSupported) {
        alert('WebSerial wird von diesem Browser nicht unterst√ºtzt. Bitte Chrome oder Edge auf dem Desktop verwenden.');
        return;
      }
      if (usbSending || bleSending) return;

      let port = null;
      let writer = null;
      let reader = null;
      let readableClosed = null;
      let lineReader = null;

      try {
        usbSending = true;
        updateActionButtons();
        setUsbStatus('USB-Log wird angefordert ‚Ä¶');

        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        // Do NOT call setSignals - leave ESP32 state unchanged
        usbLog('<>', 'Port opened for log fetch (no signal changes)');

        await delay(200);

        if (!port.writable || !port.readable) {
          throw new Error('Port bietet keine Lese-/Schreibstreams.');
        }

        const decoder = new TextDecoderStream();
        readableClosed = port.readable.pipeTo(decoder.writable).catch(() => {});
        reader = decoder.readable.getReader();
        lineReader = createLineReader(reader);
        writer = port.writable.getWriter();

        const entries = await dumpDeviceLog(lineReader, writer, 24);
        const text = entries.map((line, idx) => `${idx + 1}. ${line || '(leer)'}`).join('\n');
        if (text) {
          console.log('[USB LOG FETCH]\n' + text);
          setUsbStatus(`USB-Log erhalten (${entries.length} Eintr√§ge).`);
          showUsbErrorDialog(`USB-Log (${entries.length} Eintr√§ge):\n\n${text}`);
        } else {
          setUsbStatus('USB-Log: Keine Eintr√§ge verf√ºgbar.');
          showUsbErrorDialog('USB-Log: Keine Eintr√§ge verf√ºgbar.');
        }
      } catch (error) {
        console.error(error);
        const message = error?.message || error?.toString() || 'Unbekannter Fehler';
        setUsbStatus(`USB-Log abrufen fehlgeschlagen: ${message}`);
        await alertUsbError('USB-Log abrufen fehlgeschlagen: ' + message);
      } finally {
        try {
          if (writer) {
            await writer.releaseLock();
          }
        } catch (_) { /* noop */ }
        try {
          if (reader) {
            await reader.cancel();
          }
        } catch (_) { /* noop */ }
        try {
          if (readableClosed) {
            await readableClosed.catch(() => {});
          }
        } catch (_) { /* noop */ }
        try {
          if (port) {
            await port.close();
          }
        } catch (_) { /* noop */ }
        usbSending = false;
        updateActionButtons();
      }
    }

    function hasFilePayload(evt) {
      const dt = evt?.dataTransfer;
      if (!dt) return false;
      if (dt.types) {
        if (typeof dt.types.includes === 'function' && dt.types.includes('Files')) return true;
        if (typeof dt.types.contains === 'function' && dt.types.contains('Files')) return true;
      }
      return !!(dt.files && dt.files.length);
    }

    function extractFileFromDataTransfer(dt) {
      if (!dt) return null;
      if (dt.files && dt.files.length) return dt.files[0];
      if (dt.items) {
        for (const item of dt.items) {
          if (item.kind === 'file') {
            const file = item.getAsFile();
            if (file) return file;
          }
        }
      }
      return null;
    }

    function buildDownloadName(originalName) {
      const raw = typeof originalName === 'string' ? originalName : '';
      const normalized = raw.split(/[\\/]/).pop() || '';
      const idx = normalized.lastIndexOf('.');
      const base = idx > 0 ? normalized.slice(0, idx) : (normalized || 'image');
      const trimmed = base.trim() || 'image';
      return `${trimmed}.jpg`;
    }

    function setDropActive(active) {
      document.body.classList.toggle('drop-active', active);
    }

    async function initMozIfNeeded() {
      if (moz) {
        mozReady = true;
        return true;
      }
      try {
        moz = await moduleFactory(); // l√§dt automatisch mozjpeg_enc.wasm
        console.log('MozJPEG (WASM) bereit.');
        mozReady = true;
        updateActionButtons();
        return true;
      } catch (err) {
        console.error(err);
        alert('Konnte MozJPEG-WASM nicht laden. Pr√ºfe Internetverbindung oder nutze lokale Dateien in ./mozjpeg/');
        return false;
      }
    }

    async function setBitmapFromFile(file) {
      if (!file) return;
      if (file.type && !file.type.startsWith('image/')) {
        alert('Bitte eine Bilddatei ausw√§hlen oder ablegen.');
        return;
      }

      addDebugLog(`üöÄ Start: ${file.type}`);

      // WICHTIG: Altes Bitmap freigeben bevor neues geladen wird
      if (currentBitmap) {
        addDebugLog(`üóëÔ∏è L√∂sche altes Bitmap`);
        try {
          currentBitmap.close();
        } catch (_) {
          // close() nicht unterst√ºtzt in manchen Browsern
        }
        currentBitmap = null;

        // Canvas leeren um Speicher freizugeben
        clearCanvas();

        // Garbage Collection vorschlagen (wird nicht garantiert ausgef√ºhrt)
        if (window.gc) {
          window.gc();
        }

        // Kleine Pause um Browser Zeit zum Aufr√§umen zu geben
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      try {
        currentBitmap = await loadImageBitmap(file);
        addDebugLog(`‚úÖ Bitmap geladen`);
      } catch (err) {
        addDebugLog(`‚ùå Laden fehlgeschlagen: ${err.message}`);
        const message = err?.message || 'Konnte die Bilddatei nicht laden. Versuche es bitte mit einer anderen Datei.';
        alert(message);
        return;
      }

      const displayName = file.name ? file.name.split(/[\\/]/).pop() : '';
      currentDownloadName = buildDownloadName(displayName);
      resetCoverPan();
      resetZoom();

      try {
        drawScaled(currentBitmap);
        addDebugLog(`‚úÖ Canvas gezeichnet`);
      } catch (err) {
        addDebugLog(`‚ùå Zeichnen fehlgeschlagen: ${err.message}`);
        alert('Fehler beim Anzeigen des Bildes: ' + (err?.message || err));
        return;
      }

      updateCanvasCursor();
      fileInput.value = '';
      await initMozIfNeeded();
      updateActionButtons();
      if (!bleSending) {
        setBleStatus('');
      }
      if (!usbSending) {
        setUsbStatus('');
      }
      addDebugLog(`‚úÖ Fertig`);
    }

    // JPEG header scan to verify non-progressive:
    // Baseline SOF0 marker = 0xFFC0, Progressive SOF2 = 0xFFC2
    function isProgressiveJPEG(u8) {
      for (let i = 0; i < u8.length - 1; i++) {
        if (u8[i] === 0xFF) {
          const code = u8[i + 1];
          if (code === 0xC2) return true;   // SOF2
          if (code === 0xDA) break;         // SOS reached -> stop scanning
        }
      }
      return false;
    }

    function clearCanvas() {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, cv.width, cv.height);
      ctx.fillStyle = bgColorInput.value || '#ffffff';
      ctx.fillRect(0, 0, cv.width, cv.height);
      ctx.restore();
    }

    function resetCoverPan() {
      coverPan.x = 0;
      coverPan.y = 0;
    }

    function resetZoom() {
      zoomScale = 1.0;
    }

    async function loadImageBitmap(file) {
      // F√ºr sehr gro√üe Bilder (z.B. von Handy-Kameras): Aggressiv herunterskalieren
      // um Out-of-Memory-Fehler zu vermeiden.
      // Chrome auf Android ist sehr speicherhungrig, daher konservative Limits
      const MAX_DIMENSION = 800;     // Reduziert von 1200
      const FALLBACK_DIMENSION = 480; // Reduziert von 600

      let bmp;
      try {
        addDebugLog(`üìÅ Lade: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

        // Strategie 1: Versuche mit 800px (Seitenverh√§ltnis erhalten!)
        try {
          // WICHTIG: NUR resizeWidth ODER resizeHeight setzen, nicht beide!
          // createImageBitmap beh√§lt so das Seitenverh√§ltnis bei
          bmp = await createImageBitmap(file, {
            resizeWidth: MAX_DIMENSION,
            resizeQuality: 'high',
            imageOrientation: 'from-image'  // EXIF-Orientierung ber√ºcksichtigen
          });
          addDebugLog(`‚úÖ Bitmap: ${bmp.width}x${bmp.height} (${MAX_DIMENSION}px)`);
          return bmp;
        } catch (err1) {
          addDebugLog(`‚ö†Ô∏è ${MAX_DIMENSION}px fehlgeschlagen: ${err1.message}`);

          // Strategie 2: Fallback auf 480px
          try {
            bmp = await createImageBitmap(file, {
              resizeWidth: FALLBACK_DIMENSION,
              resizeQuality: 'medium',
              imageOrientation: 'from-image'
            });
            addDebugLog(`‚úÖ Bitmap: ${bmp.width}x${bmp.height} (${FALLBACK_DIMENSION}px Fallback)`);
            return bmp;
          } catch (err2) {
            addDebugLog(`‚ö†Ô∏è ${FALLBACK_DIMENSION}px fehlgeschlagen: ${err2.message}`);

            // Strategie 3: Ultra-klein (320px) f√ºr sehr schwache Ger√§te
            try {
              bmp = await createImageBitmap(file, {
                resizeWidth: 320,
                resizeQuality: 'low',
                imageOrientation: 'from-image'
              });
              addDebugLog(`‚úÖ Bitmap: ${bmp.width}x${bmp.height} (320px Ultra-Fallback)`);
              return bmp;
            } catch (err3) {
              addDebugLog(`‚ùå Alle Strategien fehlgeschlagen: ${err3.message}`);
              throw new Error('Bild zu gro√ü f√ºr verf√ºgbaren Speicher. Browser neu starten und versuchen Sie es mit einem kleineren Bild oder schlie√üen Sie andere Tabs.');
            }
          }
        }

      } catch (err) {
        addDebugLog(`‚ùå Fehler: ${err.message}`);
        throw new Error('Bild konnte nicht geladen werden: ' + (err?.message || err));
      }
    }

    function clampCoverPanValues(bmp, x, y) {
      if (!bmp) return { x: 0, y: 0 };
      const T = 240;
      const baseScale = Math.max(T / bmp.width, T / bmp.height);
      const s = baseScale * zoomScale;
      const w = bmp.width * s;
      const h = bmp.height * s;

      // Wenn Bild gr√∂√üer als Canvas: Einschr√§nken damit Canvas immer ausgef√ºllt ist
      // Wenn Bild kleiner als Canvas: Keine Einschr√§nkung (freies Verschieben)
      if (w > T || h > T) {
        const maxPanX = Math.max(0, (w - T) / 2);
        const maxPanY = Math.max(0, (h - T) / 2);
        return {
          x: Math.max(-maxPanX, Math.min(maxPanX, x)),
          y: Math.max(-maxPanY, Math.min(maxPanY, y))
        };
      } else {
        // Bild ist kleiner - erlaube freies Verschieben innerhalb des Canvas
        const maxPanX = T / 2;
        const maxPanY = T / 2;
        return {
          x: Math.max(-maxPanX, Math.min(maxPanX, x)),
          y: Math.max(-maxPanY, Math.min(maxPanY, y))
        };
      }
    }

    function updateCanvasCursor() {
      if (currentBitmap && modeSel.value === 'cover') {
        cv.style.cursor = isDragging ? 'grabbing' : 'grab';
      } else {
        cv.style.cursor = 'default';
      }
    }

    function drawScaled(bmp) {
      clearCanvas();

      // Weichzeichnen aktiviert ODER Zoom <= 3x: Gl√§ttung AN
      // Weichzeichnen deaktiviert UND Zoom > 3x: Gl√§ttung AUS (scharfe Pixel)
      if (pixelPerfectInput.checked || zoomScale <= 3.0) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
      } else {
        ctx.imageSmoothingEnabled = false;
      }

      const T = 240, sw = bmp.width, sh = bmp.height;
      if (modeSel.value === 'cover') {
        const baseScale = Math.max(T / sw, T / sh);
        const s = baseScale * zoomScale;
        const w = sw * s, h = sh * s;
        const clamped = clampCoverPanValues(bmp, coverPan.x, coverPan.y);
        coverPan.x = clamped.x;
        coverPan.y = clamped.y;
        const dx = (T - w) / 2 + coverPan.x;
        const dy = (T - h) / 2 + coverPan.y;
        ctx.drawImage(bmp, dx, dy, w, h);
      } else {
        const s = Math.min(T / sw, T / sh);
        const w = sw * s, h = sh * s;
        const dx = (T - w) / 2, dy = (T - h) / 2;
        ctx.drawImage(bmp, dx, dy, w, h);
      }
    }

    document.documentElement.addEventListener('dragenter', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (dropDepth++ === 0) {
        setDropActive(true);
      }
    });

    document.documentElement.addEventListener('dragover', (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'copy';
      }
    });

    document.documentElement.addEventListener('dragleave', () => {
      if (dropDepth > 0) dropDepth--;
      if (dropDepth === 0) {
        setDropActive(false);
      }
    });

    document.documentElement.addEventListener('drop', async (e) => {
      if (!hasFilePayload(e)) return;
      e.preventDefault();
      dropDepth = 0;
      setDropActive(false);
      const file = extractFileFromDataTransfer(e.dataTransfer);
      await setBitmapFromFile(file);
    });

    window.addEventListener('blur', () => {
      dropDepth = 0;
      setDropActive(false);
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      await setBitmapFromFile(file);
    });

    modeSel.addEventListener('change', () => {
      if (isDragging) {
        isDragging = false;
      }
      resetCoverPan();
      resetZoom();
      updateCanvasCursor();
      if (currentBitmap) drawScaled(currentBitmap);
    });

    bgColorInput.addEventListener('input', () => {
      if (currentBitmap) drawScaled(currentBitmap);
    });

    pixelPerfectInput.addEventListener('change', () => {
      if (currentBitmap) drawScaled(currentBitmap);
    });

    cv.addEventListener('wheel', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      e.preventDefault();

      const T = 240;
      const centerX = 120, centerY = 120;

      // Aktueller Zoom-Zustand
      const oldBaseScale = Math.max(T / currentBitmap.width, T / currentBitmap.height);
      const oldS = oldBaseScale * zoomScale;
      const oldW = currentBitmap.width * oldS, oldH = currentBitmap.height * oldS;
      const oldDx = (T - oldW) / 2 + coverPan.x;
      const oldDy = (T - oldH) / 2 + coverPan.y;

      // Punkt im Bitmap, der momentan im Zentrum des Viewports ist
      const bitmapX = (centerX - oldDx) / oldS;
      const bitmapY = (centerY - oldDy) / oldS;

      // Neuer Zoom berechnen (multiplikativ f√ºr gleichm√§√üige Schritte)
      const zoomFactor = 1.15; // 15% pro Schritt
      const delta = -Math.sign(e.deltaY);
      const newZoom = delta > 0 ? zoomScale * zoomFactor : zoomScale / zoomFactor;
      zoomScale = Math.max(0.1, Math.min(150.0, newZoom));

      // Nach Zoom: Pan-Position anpassen, damit derselbe Bitmap-Punkt im Zentrum bleibt
      const newS = oldBaseScale * zoomScale;
      const newW = currentBitmap.width * newS, newH = currentBitmap.height * newS;
      const newDx = centerX - bitmapX * newS;
      const newDy = centerY - bitmapY * newS;
      coverPan.x = newDx - (T - newW) / 2;
      coverPan.y = newDy - (T - newH) / 2;

      drawScaled(currentBitmap);
    }, { passive: false });

    cv.addEventListener('pointerdown', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      e.preventDefault();
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      panStart = { x: coverPan.x, y: coverPan.y };
      try {
        cv.setPointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    });

    cv.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      const nextPan = clampCoverPanValues(currentBitmap, panStart.x + dx, panStart.y + dy);
      coverPan.x = nextPan.x;
      coverPan.y = nextPan.y;
      drawScaled(currentBitmap);
    });

    function endDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      try {
        cv.releasePointerCapture(e.pointerId);
      } catch (_) {
        /* ignore */
      }
      updateCanvasCursor();
    }

    cv.addEventListener('pointerup', endDrag);
    cv.addEventListener('pointercancel', endDrag);

    // Touch-Pinch-Zoom f√ºr Mobile
    function getTouchDistance(touches) {
      if (touches.length < 2) return 0;
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getTouchCenter(touches) {
      if (touches.length < 2) return { x: 0, y: 0 };
      return {
        x: (touches[0].clientX + touches[1].clientX) / 2,
        y: (touches[0].clientY + touches[1].clientY) / 2
      };
    }

    cv.addEventListener('touchstart', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      if (e.touches.length === 2) {
        e.preventDefault();
        touchStartDistance = getTouchDistance(e.touches);
        touchStartZoom = zoomScale;
        touchCenter = getTouchCenter(e.touches);
      }
    }, { passive: false });

    cv.addEventListener('touchmove', (e) => {
      if (!currentBitmap || modeSel.value !== 'cover') return;
      if (e.touches.length === 2) {
        e.preventDefault();

        const currentDistance = getTouchDistance(e.touches);
        const currentCenter = getTouchCenter(e.touches);

        if (touchStartDistance > 0) {
          const T = 240;
          const rect = cv.getBoundingClientRect();
          const canvasCenterX = rect.left + rect.width / 2;
          const canvasCenterY = rect.top + rect.height / 2;

          // Aktueller Zoom-Zustand vor der √Ñnderung
          const oldBaseScale = Math.max(T / currentBitmap.width, T / currentBitmap.height);
          const oldS = oldBaseScale * zoomScale;
          const oldW = currentBitmap.width * oldS, oldH = currentBitmap.height * oldS;
          const oldDx = (T - oldW) / 2 + coverPan.x;
          const oldDy = (T - oldH) / 2 + coverPan.y;

          // Punkt im Canvas relativ zum Canvas-Center (in Canvas-Koordinaten)
          const canvasPointX = ((currentCenter.x - canvasCenterX) / rect.width) * T + T/2;
          const canvasPointY = ((currentCenter.y - canvasCenterY) / rect.height) * T + T/2;

          // Punkt im Bitmap, der unter dem Touch-Center liegt
          const bitmapX = (canvasPointX - oldDx) / oldS;
          const bitmapY = (canvasPointY - oldDy) / oldS;

          // Neuer Zoom basierend auf Pinch-Distanz
          const scale = currentDistance / touchStartDistance;
          const newZoom = touchStartZoom * scale;
          zoomScale = Math.max(0.1, Math.min(150.0, newZoom));

          // Nach Zoom: Pan-Position anpassen, damit derselbe Bitmap-Punkt unter dem Touch-Center bleibt
          const newS = oldBaseScale * zoomScale;
          const newW = currentBitmap.width * newS, newH = currentBitmap.height * newS;
          const newDx = canvasPointX - bitmapX * newS;
          const newDy = canvasPointY - bitmapY * newS;
          coverPan.x = newDx - (T - newW) / 2;
          coverPan.y = newDy - (T - newH) / 2;

          drawScaled(currentBitmap);
        }
      }
    }, { passive: false });

    cv.addEventListener('touchend', (e) => {
      if (e.touches.length < 2) {
        touchStartDistance = 0;
      }
    });

    btnSave.addEventListener('click', async () => {
      if (bleSending || usbSending) return;
      btnSave.disabled = true;
      try {
        const { bytes, filename } = await encodeCurrentImage();
        const blob = new Blob([bytes], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename || 'image.jpg';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
      } finally {
        updateActionButtons();
      }
    });

    if (btnUsb) {
      btnUsb.addEventListener('click', (e) => {
        console.log('[DEBUG] USB-Button geklickt', e);
        sendViaUsb();
      });
      if (!secureContext) {
        btnUsb.title = 'WebSerial ben√∂tigt HTTPS oder localhost.';
        setUsbStatus('WebSerial ben√∂tigt eine sichere Herkunft. Bitte die Seite √ºber https:// oder http://localhost ausliefern (z. B. \"python -m http.server\" nutzen) und dann erneut versuchen.');
      } else if (!serialAvailable) {
        btnUsb.title = 'WebSerial wird von diesem Browser nicht freigegeben.';
        setUsbStatus('WebSerial wird von diesem Browser/Profil nicht unterst√ºtzt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge auf dem Desktop.');
      }
    }

    /*
    if (btnUsbLog) {
      btnUsbLog.addEventListener('click', (e) => {
        console.log('[DEBUG] USB-Log-Button geklickt', e);
        fetchUsbLogManually();
      });
      if (!secureContext) {
        btnUsbLog.title = 'WebSerial ben√∂tigt HTTPS oder localhost.';
      } else if (!serialAvailable) {
        btnUsbLog.title = 'WebSerial wird von diesem Browser nicht freigegeben.';
      }
    }
    */

    btnBle.addEventListener('click', sendViaBle);

    if (!secureContext) {
      btnBle.title = 'WebBluetooth ben√∂tigt HTTPS oder localhost.';
      setBleStatus('WebBluetooth ben√∂tigt eine sichere Herkunft. Bitte die Seite √ºber https:// oder http://localhost ausliefern (z. B. "python -m http.server" nutzen) und dann erneut versuchen.');
    } else if (!bleAvailable) {
      btnBle.title = 'WebBluetooth wird von diesem Browser nicht freigegeben.';
      setBleStatus('WebBluetooth wird von diesem Browser/Profil nicht unterst√ºtzt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge.');
    }

    updateActionButtons();
  </script>
</body>
</html>

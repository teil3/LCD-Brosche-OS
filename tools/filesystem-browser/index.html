<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dateisystem Browser</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 1100px; margin: 2rem auto; padding: 0 1rem; background: #f8f9fb; color: #1f252d; }
    header { margin-bottom: 1rem; display: flex; align-items: flex-start; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap; }
    .header__text { flex: 1 1 320px; min-width: 0; }
    .header__logo { display: block; flex: 0 0 auto; width: 160px; margin-left: auto; order: 0; }
    .header__logo img { display: block; width: 100%; max-width: 100%; height: auto; }
    h1 { font-size: clamp(1.4rem, 2.5vw, 2rem); margin: 0 0 .25rem; }
    .muted { opacity: .75; }
    .card { background: #fff; border-radius: .8rem; padding: 1.25rem; box-shadow: 0 1px 3px rgba(0,0,0,.05); margin-bottom: 1rem; }
    button, input, select { font: inherit; border-radius: .6rem; border: 1px solid #c9c9c9; padding: .55rem .8rem; background: #ffffff; color: inherit; }
    button { cursor: pointer; font-weight: 500; }
    button:hover:not(:disabled) { background: #f0f2f7; }
    button.primary { background: #4a90e2; color: #fff; border-color: #4a90e2; }
    button.primary:hover:not(:disabled) { background: #3d7bc4; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .controls { display: flex; gap: 0.6rem; flex-wrap: wrap; margin-bottom: 0.5rem; }
    .status { min-height: 1.2rem; font-size: 0.9rem; }
    .fs-info { display: flex; gap: 1rem; flex-wrap: wrap; }
    .fs-info div { flex: 1 1 120px; background: #f0f4ff; border-radius: .6rem; padding: 0.6rem 0.8rem; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 0.4rem 0.5rem; border-bottom: 1px solid #e5e9f2; text-align: left; }
    th { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.04em; color: #6b778c; }
    .path-cell { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 0.92rem; }
    .tag { font-size: 0.72rem; padding: 0.1rem 0.4rem; border-radius: 999px; background: #e7f1ff; color: #1d4ed8; margin-left: 0.4rem; }
    .tag.lock { background: #ffe8cc; color: #b45309; }
    .tag.dir { background: #f1f5f9; color: #0f172a; }
    .actions { display: flex; gap: 0.4rem; }
    .upload-grid { display: flex; flex-wrap: wrap; gap: 0.8rem; align-items: center; }
    .upload-grid label { font-weight: 600; }
    .upload-grid select { min-width: 200px; }
    .notice { font-size: 0.85rem; margin-top: 0.4rem; }
    .hidden { display: none; }
    @media (max-width: 680px) {
      header { flex-direction: column; align-items: center; text-align: center; }
      .header__text { flex: 1 1 auto; }
      .header__logo { order: -1; margin-left: 0; margin-bottom: .75rem; }
      body { padding: 1rem; }
      .fs-info { flex-direction: column; }
      .controls { flex-direction: column; align-items: stretch; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header__text">
      <h1>Dateisystem Browser für die LCD-Brosche</h1>
      <p class="muted">Dateien inspizieren, hochladen und entfernen –  über USB.</p>
      <p class="muted" style="margin-top: .5rem; font-size: .85rem;">
        <a href="../../#webtools" style="color: #4a90e2; text-decoration: none;">← Zurück zur Dokumentation</a>
      </p>
    </div>
    <a class="header__logo" href="https://www.teil3.ch" target="_blank" rel="noopener">
      <img src="../bildaufbereiter/teil3_logo.svg" alt="Teil3 Logo" width="160" height="95" />
    </a>
  </header>

  <section class="card">
    <div class="controls">
      <button id="connect-btn" class="primary">Verbinden</button>
      <button id="disconnect-btn" class="hidden">Trennen</button>
      <button id="refresh-btn" disabled>Aktualisieren</button>
    </div>
    <p id="status" class="status muted">Bereit.</p>
  </section>

  <section class="card">
    <h2>Speicherübersicht</h2>
    <div class="fs-info">
      <div>
        <div class="muted">Gesamt</div>
        <div id="fs-total">&mdash;</div>
      </div>
      <div>
        <div class="muted">Belegt</div>
        <div id="fs-used">&mdash;</div>
      </div>
      <div>
        <div class="muted">Frei</div>
        <div id="fs-free">&mdash;</div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>LittleFS Inhalte</h2>
    <table>
      <thead>
        <tr>
          <th>Pfad</th>
          <th>Typ</th>
          <th>Größe</th>
          <th>Aktionen</th>
        </tr>
      </thead>
      <tbody id="fs-table">
        <tr><td colspan="4" class="muted">Noch keine Daten geladen.</td></tr>
      </tbody>
    </table>
  </section>

  <section class="card">
    <h2>Datei hochladen</h2>
    <form id="upload-form">
      <div class="upload-grid">
        <label for="upload-file">Datei auswählen</label>
        <input type="file" id="upload-file" required />
        <label for="upload-dir">Zielverzeichnis</label>
        <select id="upload-dir" required>
          <option value="/">/</option>
        </select>
        <button type="submit" id="upload-btn" class="primary" disabled>Upload starten</button>
      </div>
      <p class="notice">Wähle ein existierendes Verzeichnis als Ziel. <code>textapp.cfg</code>, <code>/system/font.vlw</code>, <code>/system/fontsmall.vlw</code>, <code>/system/i18n*.json</code> und Standard-Fonts in <code>/system/fonts/</code> sind schreibgeschützt. Eigene Fonts können hinzugefügt und entfernt werden. Der Expert-Modus deaktiviert alle Löschschutzmechanismen.</p>
    </form>
  </section>

  <div style="margin-top: 2rem; padding: 0.5rem; text-align: center;">
    <label style="display: inline-flex; align-items: center; gap: 0.4rem; font-size: 0.8rem; opacity: 0.5; cursor: pointer;">
      <input type="checkbox" id="expert-mode" style="width: auto; margin: 0;">
      <span>Expert-Modus</span>
    </label>
  </div>

  <script type="module">
    const connectBtn = document.getElementById('connect-btn');
    const disconnectBtn = document.getElementById('disconnect-btn');
    const refreshBtn = document.getElementById('refresh-btn');
    const statusEl = document.getElementById('status');
    const fsTable = document.getElementById('fs-table');
    const fsTotalEl = document.getElementById('fs-total');
    const fsUsedEl = document.getElementById('fs-used');
    const fsFreeEl = document.getElementById('fs-free');
    const uploadForm = document.getElementById('upload-form');
    const uploadFileInput = document.getElementById('upload-file');
    const uploadDirSelect = document.getElementById('upload-dir');
    const uploadBtn = document.getElementById('upload-btn');

    const textEncoder = new TextEncoder();
    let port = null;
    let reader = null;
    let writer = null;
    let readableClosed = null;
    let lineReader = null;
    let busy = false;

    const hiddenPaths = new Set(['/system/bootlogo.jpg']);

    // Protected fonts that cannot be deleted
    const protectedFonts = new Set([
      '/system/fonts/freesans12pt.vlw',
      '/system/fonts/freesans18pt.vlw',
      '/system/fonts/freesans24pt.vlw',
      '/system/fonts/freesansbold12pt.vlw',
      '/system/fonts/freesansbold18pt.vlw',
      '/system/fonts/freesansbold24pt.vlw',
      '/system/fonts/freeserif12pt.vlw',
      '/system/fonts/freeserif18pt.vlw',
      '/system/fonts/freeserif24pt.vlw'
    ]);

    function isProtected(path) {
      // Expert mode bypasses all protection
      const expertMode = document.getElementById('expert-mode')?.checked || false;
      if (expertMode) return false;

      const lower = path.toLowerCase();
      return lower === '/textapp.cfg' ||
             lower === '/system/font.vlw' ||
             lower === '/system/fontsmall.vlw' ||
             lower === '/system/i18n.json' ||
             lower.startsWith('/system/i18n_') ||
             protectedFonts.has(lower);
    }

    function isHidden(path) {
      return hiddenPaths.has(path.toLowerCase());
    }

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg;
    }

    function formatBytes(bytes) {
      if (bytes == null || isNaN(bytes)) return '—';
      if (bytes < 1024) return bytes + ' B';
      const units = ['KB', 'MB', 'GB'];
      let value = bytes;
      let unit = 'KB';
      let idx = 0;
      while (value >= 1024 && idx < units.length) {
        value /= 1024;
        unit = units[idx++];
      }
      return value.toFixed(value >= 10 ? 1 : 2) + ' ' + unit;
    }

    function normalizePath(input) {
      if (!input) return '/';
      let path = input.trim();
      if (!path.startsWith('/')) path = '/' + path;
      path = path.replace(/\\/g, '/');
      path = path.replace(/\/+/g, '/');
      while (path.length > 1 && path.endsWith('/')) {
        path = path.slice(0, -1);
      }
      return path || '/';
    }

    function createLineReader(sourceReader) {
      let buffer = '';
      return {
        async readLine(timeoutMs = 4000) {
          const deadline = timeoutMs ? performance.now() + timeoutMs : null;
          while (true) {
            const newlineIdx = buffer.indexOf('\n');
            if (newlineIdx >= 0) {
              const line = buffer.slice(0, newlineIdx);
              buffer = buffer.slice(newlineIdx + 1);
              return line.replace(/\r$/, '');
            }
            const readPromise = sourceReader.read();
            let result;
            if (deadline !== null) {
              const remaining = deadline - performance.now();
              if (remaining <= 0) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
              result = await Promise.race([
                readPromise,
                new Promise(resolve => setTimeout(() => resolve({ timeout: true }), remaining))
              ]);
              if (result?.timeout) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
            } else {
              result = await readPromise;
            }
            if (result.done) {
              if (buffer.length > 0) {
                const remaining = buffer;
                buffer = '';
                return remaining;
              }
              throw new Error('Serielle Verbindung geschlossen');
            }
            if (result.value) {
              buffer += result.value;
            }
          }
        }
      };
    }

    async function readUsbPayload(timeoutMs = 4000) {
      while (true) {
        const line = await lineReader.readLine(timeoutMs);
        if (!line) continue;
        if (!line.startsWith('USB')) continue;
        const payload = line.slice(3).trimStart();
        return payload;
      }
    }

    async function waitForOk(prefix, timeoutMs = 4000) {
      while (true) {
        const payload = await readUsbPayload(timeoutMs);
        if (payload.startsWith('ERR')) {
          throw new Error(payload);
        }
        if (payload.startsWith(prefix)) {
          return payload;
        }
      }
    }

    async function connectDevice() {
      if (!('serial' in navigator)) {
        alert('WebSerial wird von diesem Browser nicht unterstützt. Bitte Chrome oder Edge verwenden.');
        return;
      }
      try {
        setStatus('Seriellen Port auswählen...');
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        const decoder = new TextDecoderStream();
        readableClosed = port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();
        lineReader = createLineReader(reader);
        writer = port.writable.getWriter();

        await sendPing();
        setStatus('Verbunden. Lade Dateiliste...');
        connectBtn.classList.add('hidden');
        disconnectBtn.classList.remove('hidden');
        refreshBtn.disabled = false;
        uploadBtn.disabled = false;
        await refreshFilesystem();
      } catch (err) {
        console.error(err);
        setStatus('Fehler: ' + (err?.message || err));
        await disconnectDevice();
      }
    }

    async function disconnectDevice() {
      refreshBtn.disabled = true;
      uploadBtn.disabled = true;

      // Reset expert mode checkbox
      const expertCheckbox = document.getElementById('expert-mode');
      if (expertCheckbox) {
        expertCheckbox.checked = false;
      }

      if (writer) {
        try { await writer.releaseLock(); } catch (_) {}
        writer = null;
      }
      if (reader) {
        try { await reader.cancel(); } catch (_) {}
        reader = null;
      }
      if (readableClosed) {
        try { await readableClosed.catch(() => {}); } catch (_) {}
        readableClosed = null;
      }
      if (port) {
        try { await port.close(); } catch (_) {}
        port = null;
      }
      lineReader = null;
      connectBtn.classList.remove('hidden');
      disconnectBtn.classList.add('hidden');
      setStatus('Verbindung getrennt.');
    }

    async function sendPing() {
      await writer.write(textEncoder.encode('PING\n'));
      await waitForOk('OK PONG');
    }

    async function fetchFsInfo() {
      await writer.write(textEncoder.encode('FSINFO\n'));
      const payload = await waitForOk('OK FSINFO');
      const parts = payload.split(/\s+/);
      if (parts.length < 5) throw new Error('Ungültige FSINFO-Antwort');
      const total = Number(parts[2]);
      const used = Number(parts[3]);
      const free = Number(parts[4]);
      fsTotalEl.textContent = formatBytes(total);
      fsUsedEl.textContent = formatBytes(used);
      fsFreeEl.textContent = formatBytes(free);
    }

    function joinPath(dir, name) {
      if (!dir || dir === '/') return '/' + name;
      return (dir + '/' + name).replace(/\/+/g, '/');
    }

    async function listDirectory(dir) {
      const command = dir === '/' ? 'LIST\n' : `LIST ${dir}\n`;
      await writer.write(textEncoder.encode(command));
      const entries = [];
      while (true) {
        const payload = await readUsbPayload();
        if (payload.startsWith('ERR')) {
          throw new Error(payload);
        }
        if (payload.startsWith('OK LISTDONE')) {
          break;
        }
        if (payload.startsWith('OK LIST')) {
          const parts = payload.split(/\s+/);
          if (parts.length < 5) continue;
          const entryType = parts[2];
          const name = parts[3];
          const size = Number(parts[4]) || 0;
          entries.push({ name, isDir: entryType === 'D', size });
        }
      }
      return entries;
    }

    async function fetchAllEntries() {
      const results = [];
      const queue = ['/'];
      while (queue.length > 0) {
        const dir = queue.shift();
        const entries = await listDirectory(dir);
        for (const entry of entries) {
          const fullPath = joinPath(dir, entry.name);
          const normalized = normalizePath(fullPath);
          if (entry.isDir) {
            results.push({ path: normalized, isDir: true, size: 0 });
            queue.push(normalized);
          } else {
            results.push({ path: normalized, isDir: false, size: entry.size });
          }
        }
      }
      return results;
    }

    function updateUploadDirOptions(entries) {
      if (!uploadDirSelect) return;

      // Remember current selection
      const currentValue = uploadDirSelect.value || '/';

      // Clear and rebuild options
      uploadDirSelect.innerHTML = '';

      // Always add root
      const rootOption = document.createElement('option');
      rootOption.value = '/';
      rootOption.textContent = '/';
      uploadDirSelect.appendChild(rootOption);

      // Ensure /system option is always available
      const systemOption = document.createElement('option');
      systemOption.value = '/system';
      systemOption.textContent = '/system';
      uploadDirSelect.appendChild(systemOption);

      // Add all directories
      const directories = entries
        .filter(e => e.isDir && !isHidden(e.path))
        .sort((a, b) => a.path.localeCompare(b.path));

      for (const dir of directories) {
        if (dir.path === '/system') continue;
        const option = document.createElement('option');
        option.value = dir.path;
        option.textContent = dir.path;
        uploadDirSelect.appendChild(option);
      }

      // Restore selection if it still exists
      if (Array.from(uploadDirSelect.options).some(opt => opt.value === currentValue)) {
        uploadDirSelect.value = currentValue;
      } else if (directories.some(d => d.path === '/slides')) {
        uploadDirSelect.value = '/slides';
      }
    }

    function renderTable(entries) {
      if (!fsTable) return;
      fsTable.innerHTML = '';
      if (!entries.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.textContent = 'Keine Dateien gefunden.';
        td.colSpan = 4;
        td.classList.add('muted');
        tr.appendChild(td);
        fsTable.appendChild(tr);
        return;
      }
      entries.sort((a, b) => {
        if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
        return a.path.localeCompare(b.path);
      });

      // Update upload directory dropdown
      updateUploadDirOptions(entries);

      for (const entry of entries) {
        if (isHidden(entry.path)) continue;
        const tr = document.createElement('tr');
        const pathTd = document.createElement('td');
        pathTd.className = 'path-cell';
        pathTd.textContent = entry.path;
        pathTd.dataset.path = entry.path;  // Store path for easy access
        if (entry.isDir) {
          const tag = document.createElement('span');
          tag.textContent = 'DIR';
          tag.className = 'tag dir';
          pathTd.appendChild(tag);
        } else if (isProtected(entry.path)) {
          const tag = document.createElement('span');
          tag.textContent = 'LOCK';
          tag.className = 'tag lock';
          pathTd.appendChild(tag);
        }
        tr.appendChild(pathTd);

        const typeTd = document.createElement('td');
        typeTd.textContent = entry.isDir ? 'Ordner' : 'Datei';
        tr.appendChild(typeTd);

        const sizeTd = document.createElement('td');
        sizeTd.textContent = entry.isDir ? '–' : formatBytes(entry.size);
        tr.appendChild(sizeTd);

        const actionsTd = document.createElement('td');
        const actionsWrap = document.createElement('div');
        actionsWrap.className = 'actions';
        if (!entry.isDir) {
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Löschen';
          delBtn.type = 'button';
          delBtn.disabled = isProtected(entry.path);
          delBtn.addEventListener('click', () => confirmDelete(entry.path));
          actionsWrap.appendChild(delBtn);
        } else {
          const span = document.createElement('span');
          span.className = 'muted';
          span.textContent = '–';
          actionsWrap.appendChild(span);
        }
        actionsTd.appendChild(actionsWrap);
        tr.appendChild(actionsTd);

        fsTable.appendChild(tr);
      }
    }

    async function confirmDelete(path) {
      if (!confirm(`Datei ${path} löschen?`)) return;
      try {
        await deletePath(path);
        setStatus(`Gelöscht: ${path}`);
        await refreshFilesystem();
      } catch (err) {
        console.error(err);
        alert('Löschen fehlgeschlagen: ' + (err?.message || err));
        setStatus('Fehler: ' + (err?.message || err));
      }
    }

    async function deletePath(path) {
      if (!writer || !lineReader) throw new Error('Nicht verbunden');
      await writer.write(textEncoder.encode(`DELETE ${path}\n`));
      await waitForOk('OK DELETE');
    }

    async function refreshFilesystem() {
      if (!writer) return;
      try {
        busy = true;
        refreshBtn.disabled = true;
        setStatus('Hole FSINFO...');
        await fetchFsInfo();
        setStatus('Liste Dateien auf...');
        const entries = await fetchAllEntries();
        renderTable(entries);
        setStatus(`Gefundene Einträge: ${entries.length}`);
      } catch (err) {
        console.error(err);
        setStatus('Fehler: ' + (err?.message || err));
      } finally {
        busy = false;
        refreshBtn.disabled = !writer;
      }
    }

    uploadForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      if (!writer) {
        alert('Bitte zuerst verbinden.');
        return;
      }
      const file = uploadFileInput.files?.[0];
      if (!file) {
        alert('Keine Datei ausgewählt.');
        return;
      }
      let dir = normalizePath(uploadDirSelect.value || '/');
      const lowerName = file.name.toLowerCase();
      if (lowerName === 'i18n.json' || lowerName.startsWith('i18n_')) {
        dir = '/system';
      }
      try {
        setStatus('Starte Upload...');
        await uploadFile(file, dir);
        setStatus(`Upload abgeschlossen: ${dir}/${file.name}`);
        uploadFileInput.value = '';
        await refreshFilesystem();
      } catch (err) {
        console.error(err);
        alert('Upload fehlgeschlagen: ' + (err?.message || err));
        setStatus('Fehler: ' + (err?.message || err));
      }
    });

    async function uploadFile(file, targetDir) {
      const arrayBuffer = await file.arrayBuffer();
      const bytes = new Uint8Array(arrayBuffer);
      await writer.write(textEncoder.encode(`START ${bytes.length} ${file.name} ${targetDir}\n`));
      await waitForOk('OK START');
      const chunkSize = 1024;
      for (let offset = 0; offset < bytes.length; offset += chunkSize) {
        const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
        await writer.write(slice);
      }
      await writer.write(textEncoder.encode('END\n'));
      await waitForOk('OK END', 10000);
    }

    refreshBtn.addEventListener('click', () => refreshFilesystem());
    connectBtn.addEventListener('click', () => connectDevice());
    disconnectBtn.addEventListener('click', () => disconnectDevice());

    // Re-render table when expert mode is toggled to update delete button states
    const expertModeCheckbox = document.getElementById('expert-mode');
    if (expertModeCheckbox) {
      expertModeCheckbox.addEventListener('change', async () => {
        const enabled = expertModeCheckbox.checked;

        // Send EXPERT command to firmware
        if (writer) {
          try {
            await writer.write(textEncoder.encode(`EXPERT ${enabled ? '1' : '0'}\n`));
            await waitForOk('OK EXPERT', 2000);
            console.log(`Expert mode ${enabled ? 'enabled' : 'disabled'} on device`);
          } catch (err) {
            console.error('Failed to set expert mode on device:', err);
            // Continue anyway - UI will still update
          }
        }

        // Update all delete buttons in the current table
        const deleteButtons = fsTable.querySelectorAll('button');
        deleteButtons.forEach(btn => {
          if (btn.textContent === 'Löschen') {
            // Get the path from the row's data attribute
            const row = btn.closest('tr');
            const pathCell = row?.querySelector('.path-cell');
            if (pathCell && pathCell.dataset.path) {
              btn.disabled = isProtected(pathCell.dataset.path);
            }
          }
        });
      });
    }
    window.addEventListener('beforeunload', () => {
      if (port) {
        disconnectDevice();
      }
    });
  </script>
</body>
</html>

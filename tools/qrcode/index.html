<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QR-Code Generator für die LCD-Brosche</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 880px; margin: 2rem auto; padding: 0 1rem; background: #f8f9fb; color: #1f252d; }
    header { margin-bottom: 1rem; display: flex; align-items: flex-start; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap; }
    .header__text { flex: 1 1 320px; min-width: 0; }
    .header__logo { display: block; flex: 0 0 auto; width: 160px; margin-left: auto; order: 0; }
    .header__logo img { display: block; width: 100%; max-width: 100%; height: auto; }
    @media (max-width: 680px) {
      header { flex-direction: column; align-items: center; text-align: center; }
      .header__text { flex: 1 1 auto; }
      .header__logo { order: -1; margin-left: 0; margin-bottom: .75rem; }
    }
    h1 { font-size: clamp(1.4rem, 2.5vw, 2rem); margin: 0 0 .25rem; }
    .muted { opacity: .75; }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; margin: .75rem 0; }
    .input-group { display: flex; flex-direction: column; gap: .4rem; flex: 1 1 200px; }
    .input-group label { font-size: .9rem; font-weight: 500; }
    .input-group textarea { padding: .55rem .8rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: #ffffff; color: inherit; font-family: inherit; font-size: 1rem; resize: vertical; min-height: 80px; }
    .color-picker { display: flex; align-items: center; gap: .4rem; }
    .color-picker input[type="color"] { width: 50px; height: 40px; border-radius: .6rem; border: 1px solid #c9c9c9; cursor: pointer; }
    .preview { position: relative; display: block; width: 270px; height: 262.5px; margin: 2.5rem auto 0; }
    .preview__viewport { position: absolute; top: 32.8px; left: 41.3px; width: 180px; height: 180px; border-radius: 50%; overflow: hidden; border: 1px solid #c9c9c9; box-shadow: 0 1px 8px rgba(0,0,0,.08); background: #fff; }
    .preview__viewport::after { content: ""; position: absolute; inset: 0; border-radius: 50%; pointer-events: none; box-shadow: inset 0 0 0 1px rgba(0,0,0,.12); }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    .preview__mask { position: absolute; top: 1px; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; pointer-events: none; object-fit: cover; }
    button, select, input[type="number"], input[type="text"] { padding: .55rem .8rem; border-radius: .6rem; border: 1px solid #c9c9c9; background: #ffffff; color: inherit; }
    button[disabled] { opacity: .5; }
    .actions { margin: 1.5rem 0 0; }
    footer { margin-top: 2rem; font-size: .9rem; }
    code { background: rgba(127,127,127,.15); padding: .1rem .3rem; border-radius: .3rem; }
    .version-tag { font-weight: 400; font-size: .72rem; opacity: .6; margin-left: .5rem; }
    .error-modal { position: fixed; inset: 0; background: rgba(15,23,42,.55); display: none; align-items: center; justify-content: center; padding: 1.5rem; z-index: 1500; }
    .error-modal.open { display: flex; }
    .error-modal__box { background: #fff; color: inherit; border-radius: .9rem; box-shadow: 0 20px 45px rgba(15,23,42,.25); max-width: min(720px, 95vw); width: 100%; padding: 1.4rem; display: flex; flex-direction: column; gap: 1rem; }
    .error-modal__title { margin: 0; font-size: 1.1rem; font-weight: 600; }
    .error-modal__textarea { width: 100%; min-height: 220px; font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .9rem; line-height: 1.35; border-radius: .6rem; border: 1px solid #ccd3dd; padding: .75rem; resize: vertical; box-sizing: border-box; }
    .error-modal__textarea:focus-visible { outline: 2px solid #4a90e2; outline-offset: 2px; }
    .error-modal__actions { display: flex; justify-content: flex-end; gap: .75rem; }
  </style>
</head>
<body>
  <header>
    <div class="header__text">
      <h1>QR-Code Generator für die LCD-Brosche <span class="muted version-tag" id="tool-version"></span></h1>
      <p class="muted">Mit dieser Anwendung kannst du QR-Codes erstellen und sie auf die Brosche übertragen. Du kannst sie per Bluetooth, USB oder über eine SD-Karte auf die Brosche übertragen.</p>
      <p class="muted" style="margin-top: .5rem; font-size: .85rem;">
        <a href="../../" style="color: #4a90e2; text-decoration: none;">← Zurück zur Dokumentation</a>
      </p>
    </div>
    <a class="header__logo" href="https://www.teil3.ch" target="_blank" rel="noopener">
      <img src="teil3_logo.svg" alt="Teil3 Logo" width="160" height="95" />
    </a>
  </header>

  <div class="row">
    <div class="input-group">
      <label for="qr-text">QR-Code Inhalt:</label>
      <textarea id="qr-text" placeholder="Text, URL oder beliebiger Inhalt für den QR-Code eingeben..." maxlength="387"></textarea>
    </div>
  </div>

  <div class="row">
    <div class="color-picker">
      <label for="code-color">Codefarbe:</label>
      <input id="code-color" type="color" value="#000000" title="Farbe der QR-Code-Module">
    </div>
    <div class="color-picker">
      <label for="bg-color">Hintergrundfarbe:</label>
      <input id="bg-color" type="color" value="#ffffff" title="Hintergrundfarbe des QR-Codes">
      <button type="button" id="invert-colors" title="Code- und Hintergrundfarbe vertauschen">Farben umkehren</button>
    </div>
  </div>

  <div class="preview">
    <div class="preview__viewport">
      <canvas id="cv" width="240" height="240"></canvas>
    </div>
    <img class="preview__mask" src="./LCD-Brosche-maske.png" alt="Maske der LCD-Brosche" />
  </div>

  <div class="actions">
    <button id="save" disabled>Als JPEG speichern</button>
    <button id="send-usb" disabled>Über USB senden</button>
    <button id="send-ble" disabled>Per Bluetooth senden</button>
    <p id="usb-status" class="muted" aria-live="polite"></p>
    <p id="ble-status" class="muted" aria-live="polite"></p>
    <p class="muted" id="ble-hint">Hinweis: Auf der Brosche den BLE-Empfangsmodus aktivieren (BTN2 in der Diashow App mehrmals lang drücken, bis "Bluetooth Modus" angezeigt wird).</p>
  </div>

  <footer>
    <p class="muted" style="font-size: .85rem;">MozJPEG Encoder: <span id="mozjpeg-source">wird geladen...</span></p>
  </footer>

  <script src="./vendor-qrcode-generator.min.js"></script>
  <script type="module">
    // --- Import der MozJPEG-WASM-Codec-Factory (jSquash) ---
    let moduleFactory = null;
    let mozModuleSource = 'unknown';
    const mozModuleErrors = [];
    const isFileProtocol = location.protocol === 'file:';

    const QR_EC_LEVELS = new Set(['L', 'M', 'Q', 'H']);
    const QR_TEXT_MAX_LENGTH = 387;
    let qrCdnScriptPromise = null;

    if (isFileProtocol) {
      console.info('[MozJPEG] file:// erkannt - verwende CDN (lokale ES6 Module via file:// nicht möglich).');
      try {
        moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;
        mozModuleSource = 'cdn';
        console.info('[MozJPEG] Encoder via CDN geladen (unpkg.com).');
      } catch (cdnError) {
        mozModuleErrors.push(cdnError);
        console.error('[MozJPEG] CDN-Import fehlgeschlagen.', cdnError);
      }
    } else {
      try {
        moduleFactory = (await import('../bildaufbereiter/mozjpeg/mozjpeg_enc.js?module')).default;
        mozModuleSource = 'local';
        console.info('[MozJPEG] Encoder aus ../bildaufbereiter/mozjpeg/ geladen (lokal).');
      } catch (localError) {
        mozModuleErrors.push(localError);
        console.warn('[MozJPEG] Lokaler Import fehlgeschlagen, versuche CDN-Fallback …', localError);
        try {
          moduleFactory = (await import('https://unpkg.com/@jsquash/jpeg@1.6.0/codec/enc/mozjpeg_enc.js?module')).default;
          mozModuleSource = 'cdn';
          console.info('[MozJPEG] Encoder via CDN geladen (unpkg.com).');
        } catch (cdnError) {
          mozModuleErrors.push(cdnError);
          console.error('[MozJPEG] CDN-Fallback fehlgeschlagen.', cdnError);
        }
      }
    }

    if (!moduleFactory) {
      const combinedError = mozModuleErrors.pop() || new Error('Unbekannter Importfehler');
      const message = isFileProtocol
        ? 'MozJPEG-WASM konnte nicht geladen werden. Bei file:// ist eine Internetverbindung erforderlich. Alternativ: Mit lokalem HTTP-Server öffnen (z.B. "python3 -m http.server").'
        : 'MozJPEG-WASM konnte nicht geladen werden. Bitte ./mozjpeg/ bereitstellen oder Internetverbindung prüfen.';
      console.error(message, { mozModuleErrors });
      alert(message);
      throw combinedError;
    }
    window.__mozjpegSource = mozModuleSource;

    function createLocalQrCodeAdapter() {
      const factory = window?.qrcode;
      if (!factory) {
        throw new Error('Lokale qrcode-generator Bibliothek nicht gefunden.');
      }
      const adapter = {
        toCanvas(canvas, text, options = {}) {
          return new Promise((resolve, reject) => {
            try {
              resolve(renderQrCodeWithGenerator(factory, canvas, text, options));
            } catch (renderErr) {
              reject(renderErr);
            }
          });
        }
      };
      console.info('[QRCode] Library geladen (lokal qrcode-generator 1.4.4).');
      adapter.__source = 'local';
      return adapter;
    }

    function renderQrCodeWithGenerator(factory, canvas, text, options) {
      if (!canvas) throw new Error('Canvas-Element fehlt.');
      if (!text) throw new Error('Kein Inhalt für den QR-Code.');
      const requestedLevel = String(options?.errorCorrectionLevel || 'M').toUpperCase();
      const level = QR_EC_LEVELS.has(requestedLevel) ? requestedLevel : 'M';
      const qr = factory(0, level);
      qr.addData(text);
      qr.make();

      const moduleCount = qr.getModuleCount();
      const marginModules = Number.isFinite(options?.margin) ? Math.max(0, options.margin) : 4;
      const matrixSize = moduleCount + marginModules * 2;

      const offscreen = document.createElement('canvas');
      offscreen.width = matrixSize;
      offscreen.height = matrixSize;
      const offCtx = offscreen.getContext('2d', { willReadFrequently: true });
      const light = options?.color?.light || '#ffffff';
      const dark = options?.color?.dark || '#000000';
      offCtx.fillStyle = light;
      offCtx.fillRect(0, 0, matrixSize, matrixSize);
      offCtx.fillStyle = dark;
      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          if (qr.isDark(row, col)) {
            offCtx.fillRect(marginModules + col, marginModules + row, 1, 1);
          }
        }
      }

      const targetSize = Math.max(1, Math.round(options?.width || canvas.width || 240));
      canvas.width = canvas.height = targetSize;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, targetSize, targetSize);
      ctx.drawImage(offscreen, 0, 0, targetSize, targetSize);
      return canvas;
    }

    function loadQrCodeGeneratorFromCdn() {
      if (!qrCdnScriptPromise) {
        qrCdnScriptPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js';
          script.async = true;
          script.onload = () => resolve();
          script.onerror = () => {
            qrCdnScriptPromise = null;
            reject(new Error('CDN konnte qrcode-generator nicht laden.'));
          };
          document.head.appendChild(script);
        });
      }
      return qrCdnScriptPromise;
    }

    // --- Import der QR-Code-Library ---
    let QRCode = null;
    const qrModuleErrors = [];
    try {
      QRCode = createLocalQrCodeAdapter();
    } catch (localError) {
      qrModuleErrors.push(localError);
      console.warn('[QRCode] Lokaler Import fehlgeschlagen, versuche CDN-Fallback …', localError);
      try {
        await loadQrCodeGeneratorFromCdn();
        QRCode = createLocalQrCodeAdapter();
        if (QRCode) {
          QRCode.__source = 'cdn';
        }
        console.info('[QRCode] Library geladen (cdn.jsdelivr.net).');
      } catch (cdnError) {
        qrModuleErrors.push(cdnError);
        console.error('[QRCode] Import fehlgeschlagen.', { qrModuleErrors });
        alert('QR-Code-Library konnte nicht geladen werden. Bitte vendor-qrcode-generator.min.js bereitstellen oder Internetverbindung prüfen.');
        throw cdnError;
      }
    }
    window.__qrcodeSource = QRCode?.__source || 'unknown';

    const TOOL_VERSION = 'V0.1';

    const qrTextInput = document.getElementById('qr-text');
    const codeColorInput = document.getElementById('code-color');
    const bgColorInput = document.getElementById('bg-color');
    const invertColorsBtn = document.getElementById('invert-colors');
    const btnSave = document.getElementById('save');
    const btnUsb = document.getElementById('send-usb');
    const btnBle = document.getElementById('send-ble');
    const versionLabel = document.getElementById('tool-version');
    const mozjpegSourceLabel = document.getElementById('mozjpeg-source');
    const usbStatus = document.getElementById('usb-status');
    const bleStatus = document.getElementById('ble-status');
    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d', { willReadFrequently: true });
    const QR_BASE_WIDTH = 240;
    const DEFAULT_QR_DRAW_SIZE = 170;
    const DEFAULT_ZOOM_SCALE = DEFAULT_QR_DRAW_SIZE / QR_BASE_WIDTH;

    const BLE_UUIDS = {
      service: '12345678-1234-1234-1234-1234567890ab',
      chunk:   'abcd0001-1234-1234-1234-1234567890ab',
      control: 'abcd0002-1234-1234-1234-1234567890ab'
    };
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();
    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    let moz = null;
    let mozReady = false;
    let qrCodeReady = false;
    let zoomScale = DEFAULT_ZOOM_SCALE;
    let panOffset = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };
    let currentDownloadName = 'qrcode-qr.jpg';
    let bleSending = false;
    let usbSending = false;
    const usbDebugLog = [];
    let usbErrorModal = null;
    let usbErrorModalText = null;
    let usbErrorModalCopyBtn = null;
    let usbErrorModalCloseBtn = null;
    let usbErrorModalKeyHandlerAttached = false;

    if (qrTextInput) {
      qrTextInput.maxLength = QR_TEXT_MAX_LENGTH;
    }

    if (versionLabel) {
      versionLabel.textContent = TOOL_VERSION;
    }
    if (mozjpegSourceLabel) {
      const sourceText = mozModuleSource === 'local' ? 'Lokal (../bildaufbereiter/mozjpeg/)' :
                         mozModuleSource === 'cdn' ? 'CDN (unpkg.com)' :
                         'unbekannt';
      mozjpegSourceLabel.textContent = sourceText;
    }

    const secureContextHosts = new Set(['localhost', '127.0.0.1', '::1']);
    const secureContext = window.isSecureContext || secureContextHosts.has(location.hostname);
    const bleAvailable = 'bluetooth' in navigator;
    const bleSupported = secureContext && bleAvailable;
    const serialAvailable = 'serial' in navigator;
    const usbSupported = secureContext && serialAvailable;

    function setUsbStatus(text) {
      if (!usbStatus) return;
      usbStatus.textContent = text || '';
    }

    function usbLog(direction, message) {
      const entry = `${direction} ${message}`;
      if (usbDebugLog.length >= 80) {
        usbDebugLog.shift();
      }
      usbDebugLog.push(entry);
      console.debug('[USB LOG]', entry);
    }

    function usbLogSnapshot() {
      return usbDebugLog.slice(-12).join('\n');
    }

    function ensureUsbErrorModal() {
      if (usbErrorModal) return usbErrorModal;
      const overlay = document.createElement('div');
      overlay.className = 'error-modal';

      const box = document.createElement('div');
      box.className = 'error-modal__box';

      const title = document.createElement('h2');
      title.className = 'error-modal__title';
      title.textContent = 'USB-Fehlerdetails';

      const textarea = document.createElement('textarea');
      textarea.className = 'error-modal__textarea';
      textarea.setAttribute('readonly', 'readonly');

      const actions = document.createElement('div');
      actions.className = 'error-modal__actions';

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.textContent = 'In Zwischenablage kopieren';

      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.textContent = 'Schliessen';

      actions.appendChild(copyBtn);
      actions.appendChild(closeBtn);
      box.appendChild(title);
      box.appendChild(textarea);
      box.appendChild(actions);
      overlay.appendChild(box);
      document.body.appendChild(overlay);

      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(textarea.value);
          copyBtn.textContent = 'Kopiert ✔';
          setTimeout(() => { copyBtn.textContent = 'In Zwischenablage kopieren'; }, 1600);
        } catch (err) {
          console.warn('Clipboard write failed', err);
        }
        textarea.focus();
        textarea.select();
      });

      closeBtn.addEventListener('click', () => {
        overlay.classList.remove('open');
      });

      overlay.addEventListener('click', (evt) => {
        if (evt.target === overlay) {
          overlay.classList.remove('open');
        }
      });

      if (!usbErrorModalKeyHandlerAttached) {
        document.addEventListener('keydown', (evt) => {
          if (evt.key === 'Escape' && overlay.classList.contains('open')) {
            overlay.classList.remove('open');
          }
        });
        usbErrorModalKeyHandlerAttached = true;
      }

      usbErrorModal = overlay;
      usbErrorModalText = textarea;
      usbErrorModalCopyBtn = copyBtn;
      usbErrorModalCloseBtn = closeBtn;
      return overlay;
    }

    function showUsbErrorDialog(message) {
      const overlay = ensureUsbErrorModal();
      if (!usbErrorModalText) return;
      usbErrorModalText.value = message;
      if (usbErrorModalCopyBtn) {
        usbErrorModalCopyBtn.textContent = 'In Zwischenablage kopieren';
      }
      requestAnimationFrame(() => {
        overlay.classList.add('open');
        usbErrorModalText.focus();
        usbErrorModalText.select();
      });
    }

    async function alertUsbError(message) {
      const log = usbLogSnapshot();
      const fullMessage = log ? `${message}\n\nLetzte USB-Meldungen:\n${log}` : message;
      console.error('USB ERROR:', message, { log: usbDebugLog.slice() });
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(fullMessage);
          usbLog('<>', 'Fehlerdetails in die Zwischenablage kopiert.');
        } catch (err) {
          usbLog('!!', `Clipboard write failed: ${err?.message || err}`);
        }
      }
      try {
        showUsbErrorDialog(fullMessage);
      } catch (err) {
        console.warn('Fallback alert (Dialog fehlgeschlagen)', err);
        alert(fullMessage);
      }
    }

    function setBleStatus(text) {
      if (!bleStatus) return;
      bleStatus.textContent = text || '';
    }

    function updateActionButtons() {
      const ready = qrCodeReady && mozReady;
      const busy = bleSending || usbSending;
      if (btnSave) btnSave.disabled = !ready || busy;
      if (btnUsb) btnUsb.disabled = !ready || !usbSupported || busy;
      if (btnBle) btnBle.disabled = !ready || !bleSupported || busy;
    }

    const FILENAME_ALLOWED_CHARS = /[A-Za-z0-9]/;

    function sanitizeFilenameForTransfer(name) {
      const fallback = 'qrcode-qr.jpg';
      if (!name) return fallback;
      let base = name.split(/[\\/]/).pop() || fallback;
      base = base.toLowerCase();
      let out = '';
      for (const ch of base) {
        if ((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch === '-' || ch === '_' || ch === '.') {
          out += ch;
        } else if (ch === ' ') {
          out += '_';
        }
        if (out.length >= 60) break;
      }
      if (!out) out = fallback;
      if (out.startsWith('.')) out = out.substring(1) || fallback;
      if (!out.endsWith('.jpg') && !out.endsWith('.jpeg')) {
        out += '.jpg';
      }
      if (out.length > 60) {
        const idx = out.lastIndexOf('.');
        const ext = idx >= 0 ? out.slice(idx) : '.jpg';
        const stem = idx >= 0 ? out.slice(0, idx) : out;
        out = stem.slice(0, Math.max(1, 60 - ext.length)) + ext;
      }
      return out;
    }

    function deriveDownloadNameFromText(text) {
      const trimmed = (text || '').trim();
      if (!trimmed) {
        return 'qrcode-qr.jpg';
      }
      let filtered = '';
      for (const ch of trimmed) {
        if (FILENAME_ALLOWED_CHARS.test(ch)) {
          filtered += ch;
        }
      }
      if (!filtered) {
        return 'qrcode-qr.jpg';
      }
      const suffix = filtered.slice(-10);
      const candidate = `${suffix}-qr.jpg`;
      return sanitizeFilenameForTransfer(candidate);
    }

    function humanReadableSize(bytes) {
      if (!Number.isFinite(bytes)) return '0 B';
      if (bytes < 1024) return `${bytes} B`;
      const kb = bytes / 1024;
      const rounded = Math.round(kb * 10) / 10;
      return `${rounded.toFixed(rounded % 1 === 0 ? 0 : 1)} KB`;
    }

    async function generateQRCode() {
      const text = qrTextInput.value.trim();
      if (!text) {
        ctx.fillStyle = bgColorInput.value;
        ctx.fillRect(0, 0, cv.width, cv.height);
        qrCodeReady = false;
        currentDownloadName = 'qrcode-qr.jpg';
        updateActionButtons();
        return;
      }
      currentDownloadName = deriveDownloadNameFromText(text);

      try {
        // Generate QR code to temporary canvas
        const tempCanvas = document.createElement('canvas');
        const options = {
          errorCorrectionLevel: 'M',
          type: 'image/png',
          quality: 1,
          margin: 1,
          color: {
            dark: codeColorInput.value,
            light: bgColorInput.value
          },
          width: QR_BASE_WIDTH
        };

        await QRCode.toCanvas(tempCanvas, text, options);

        // Draw to main canvas with current transform
        drawQRToCanvas(tempCanvas);

        qrCodeReady = true;
        updateActionButtons();
      } catch (err) {
        console.error('[QRCode] Generation failed:', err);
        alert('Fehler beim Generieren des QR-Codes: ' + (err?.message || err));
        qrCodeReady = false;
        updateActionButtons();
      }
    }

    function drawQRToCanvas(qrCanvas) {
      // Clear canvas with background color
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = bgColorInput.value;
      ctx.fillRect(0, 0, cv.width, cv.height);
      ctx.restore();

      if (!qrCanvas) return;

      // Calculate scaled dimensions
      const scale = zoomScale;
      const qrWidth = qrCanvas.width * scale;
      const qrHeight = qrCanvas.height * scale;

      // Clamp pan values
      const maxPanX = Math.max(0, (qrWidth - cv.width) / 2);
      const maxPanY = Math.max(0, (qrHeight - cv.height) / 2);
      panOffset.x = Math.max(-maxPanX, Math.min(maxPanX, panOffset.x));
      panOffset.y = Math.max(-maxPanY, Math.min(maxPanY, panOffset.y));

      // Calculate position (centered + pan offset)
      const dx = (cv.width - qrWidth) / 2 + panOffset.x;
      const dy = (cv.height - qrHeight) / 2 + panOffset.y;

      // Disable smoothing for sharp QR code
      ctx.imageSmoothingEnabled = false;

      // Draw QR code
      ctx.drawImage(qrCanvas, dx, dy, qrWidth, qrHeight);
    }

    async function encodeCurrentImage() {
      if (!qrCodeReady) {
        alert('Bitte zuerst einen QR-Code generieren.');
        throw new Error('Kein QR-Code vorhanden');
      }
      const ready = await initMozIfNeeded();
      if (!ready || !moz) {
        throw new Error('JPEG-Codec nicht verfügbar');
      }
      const { data } = ctx.getImageData(0, 0, cv.width, cv.height);
      const quality = 92; // Fixed quality
      const opts = {
        quality,
        baseline: true,
        progressive: false,
        arithmetic: false,
        optimize_coding: true,
        smoothing: 0,
        color_space: 3,
        quant_table: 3,
        trellis_multipass: false,
        trellis_opt_zero: false,
        trellis_opt_table: false,
        trellis_loops: 1,
        auto_subsample: false,
        chroma_subsample: 2,
        separate_chroma_quality: false,
        chroma_quality: quality
      };

      try {
        const jpegU8 = moz.encode(data, 240, 240, opts);
        return {
          bytes: jpegU8,
          filename: currentDownloadName
        };
      } catch (error) {
        console.error(error);
        alert('Fehler beim JPEG-Encode: ' + (error?.message || error));
        throw error;
      }
    }

    async function writeBle(characteristic, data) {
      await characteristic.writeValue(data);
    }

    async function waitFor(predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (performance.now() < deadline) {
        if (predicate()) return true;
        await delay(50);
      }
      return predicate();
    }

    function createLineReader(reader) {
      let buffer = '';
      return {
        async readLine(timeoutMs) {
          const deadline = (typeof timeoutMs === 'number')
            ? performance.now() + timeoutMs
            : null;
          while (true) {
            const newlineIdx = buffer.indexOf('\n');
            if (newlineIdx >= 0) {
              const line = buffer.slice(0, newlineIdx);
              buffer = buffer.slice(newlineIdx + 1);
              return line.replace(/\r$/, '');
            }

            const readPromise = reader.read();
            let result;
            if (deadline !== null) {
              const remaining = deadline - performance.now();
              if (remaining <= 0) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
              result = await Promise.race([
                readPromise,
                delay(Math.max(remaining, 0)).then(() => ({ timeout: true })),
              ]);
              if (result?.timeout) {
                throw new Error('Timeout beim Lesen von Gerätedaten');
              }
            } else {
              result = await readPromise;
            }

            if (result.done) {
              if (buffer.length > 0) {
                const line = buffer;
                buffer = '';
                return line.replace(/\r$/, '');
              }
              throw new Error('Verbindung geschlossen');
            }
            if (result.value) {
              buffer += result.value;
            }
          }
        }
      };
    }

    async function waitForUsbLine(lineReader, predicate, timeoutMs) {
      const deadline = performance.now() + timeoutMs;
      while (true) {
        const remaining = deadline - performance.now();
        if (remaining <= 0) {
          throw new Error('Timeout beim Warten auf Antwort des Geräts');
        }
        const line = (await lineReader.readLine(Math.max(remaining, 50))).trim();
        if (!line) continue;
        usbLog('<=', line);
        if (!line.startsWith('USB')) {
          continue;
        }
        const payload = line.slice(3).trimStart();
        if (payload.startsWith('ERR')) {
          const message = payload.substring(3).trim();
          throw new Error(message || 'Gerätefehler');
        }
        if (payload.startsWith('OK PROG')) {
          const parts = payload.split(/\s+/);
          if (parts.length >= 4) {
            const received = Number(parts[2]);
            const total = Number(parts[3]);
            if (Number.isFinite(received) && Number.isFinite(total) && total > 0) {
              const pct = Math.min(100, Math.round((received / total) * 100));
              setUsbStatus(`Gerät empfängt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          }
          continue;
        }
        if (payload.startsWith('OK MSG')) {
          const msg = payload.substring(6).trim();
          if (msg) setUsbStatus(msg);
          continue;
        }
        if (predicate(payload)) {
          return payload;
        }
      }
    }

    async function dumpDeviceLog(lineReader, writer, maxEntries = 16) {
      if (!writer || !lineReader) return [];
      try {
        usbLog('->', 'LOG');
        await writer.write(textEncoder.encode('LOG\n'));
      } catch (err) {
        usbLog('!!', `LOG senden fehlgeschlagen: ${err?.message || err}`);
        return [];
      }

      let ack;
      try {
        ack = await waitForUsbLine(
          lineReader,
          (payload) => payload.startsWith('OK LOG') || payload.startsWith('ERR'),
          2000
        );
      } catch (err) {
        usbLog('!!', `LOG-Antwort ausstehend: ${err?.message || err}`);
        return [];
      }

      if (ack.startsWith('ERR')) {
        usbLog('!!', `Gerät meldet LOG-Fehler: ${ack}`);
        return [];
      }

      const parts = ack.split(/\s+/);
      let count = Number(parts[2]);
      if (!Number.isFinite(count) || count <= 0) {
        count = maxEntries;
      }
      const limit = Math.min(count, Math.max(1, maxEntries));
      const entries = [];
      let guard = 0;

      while (entries.length < limit && guard < limit + 8) {
        guard += 1;
        try {
          const raw = (await lineReader.readLine(800)).trim();
          if (!raw) continue;
          usbLog('<=', raw);
          if (raw.startsWith('USB LOG')) {
            entries.push(raw.substring(7).trim());
          }
        } catch (err) {
          if (entries.length === 0) {
            usbLog('!!', `LOG lesen fehlgeschlagen: ${err?.message || err}`);
          } else {
            usbLog('<>', 'LOG lesen beendet (Timeout)');
          }
          break;
        }
      }

      if (!entries.length) {
        usbLog('<>', 'Keine LOG-Einträge vom Gerät erhalten.');
      }
      return entries;
    }

    async function sendViaUsb() {
      if (!usbSupported) {
        alert('WebSerial wird von diesem Browser nicht unterstützt. Bitte Chrome oder Edge auf dem Desktop verwenden.');
        return;
      }
      if (usbSending || bleSending) return;
      if (!qrCodeReady) {
        alert('Bitte zuerst einen QR-Code generieren.');
        return;
      }

      usbDebugLog.length = 0;

      let port = null;
      let writer = null;
      let reader = null;
      let readableClosed = null;
      let lineReader = null;
      let transferCompleted = false;
      let sent = 0;
      let totalSize = 0;

      try {
        usbSending = true;
        updateActionButtons();
        setUsbStatus('QR-Code wird vorbereitet …');
        usbLog('<>', 'Beginne USB-Transfer');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);
        totalSize = bytes.length;
        const totalLabel = humanReadableSize(totalSize);

        setUsbStatus('Seriellen Port auswählen …');
        port = await navigator.serial.requestPort();

        usbLog('<>', 'Performing port reset cycle (simulating monitor trick)...');
        try {
          await port.open({ baudRate: 115200 });
          await delay(100);
          await port.close();
          usbLog('<>', 'Port reset: closed');
          await delay(200);
        } catch (err) {
          usbLog('!!', `Port reset cycle failed (non-critical): ${err?.message || err}`);
        }

        try {
          await port.open({ baudRate: 115200 });
        } catch (err) {
          usbLog('!!', `open failed: ${err?.message || err}`);
          throw err;
        }

        usbLog('<>', 'Port opened after reset cycle');
        await delay(300);

        if (!port.writable) {
          throw new Error('Port bietet keinen Schreibstream.');
        }
        if (!port.readable) {
          throw new Error('Port bietet keinen Lesestream.');
        }

        if (typeof TextDecoderStream === 'undefined') {
          throw new Error('TextDecoderStream wird nicht unterstützt. Bitte einen aktuellen Chromium-Browser verwenden.');
        }
        const decoder = new TextDecoderStream();
        readableClosed = port.readable.pipeTo(decoder.writable).catch(() => {});
        reader = decoder.readable.getReader();
        lineReader = createLineReader(reader);

        writer = port.writable.getWriter();

        usbLog('<>', 'Prüfe Verbindung mit PING…');
        await delay(100);

        const maxPingRetries = 5;
        let pingSuccess = false;
        let lastPingError = null;

        for (let attempt = 1; attempt <= maxPingRetries; attempt++) {
          try {
            if (attempt > 1) {
              setUsbStatus(`Warte auf Transfer-Modus... (Versuch ${attempt}/${maxPingRetries})`);
              usbLog('<>', `PING retry attempt ${attempt}/${maxPingRetries}`);
              await delay(1000); // 1 Sekunde zwischen Retries
            }

            usbLog('->', 'PING');
            await writer.write(textEncoder.encode('PING\n'));

            const pong = await waitForUsbLine(
              lineReader,
              (payload) => payload.startsWith('OK PONG') || payload.startsWith('ERR'),
              3000
            );

            if (pong.startsWith('ERR')) {
              usbLog('!!', `Gerät meldet Fehler auf PING: ${pong}`);
              throw new Error('Gerät meldet Fehler');
            }

            usbLog('<=', pong);
            setUsbStatus('Gerät antwortet – Übertragung wird vorbereitet …');
            pingSuccess = true;
            break;

          } catch (err) {
            lastPingError = err;
            usbLog('!!', `PING Versuch ${attempt} fehlgeschlagen: ${err?.message || err}`);
            // Continue to next retry
          }
        }

        if (!pingSuccess) {
          usbLog('!!', `Alle ${maxPingRetries} PING-Versuche fehlgeschlagen`);
          throw new Error(`Transfer-Modus nicht aktiv. Bitte BTN2 lang halten bis "TRANSFER" angezeigt wird, dann erneut versuchen.`);
        }

        const startLine = `START ${totalSize} ${sanitizedName}\n`;
        usbLog('->', startLine.trim());
        await writer.write(textEncoder.encode(startLine));

        let startAck = null;
        try {
          startAck = await waitForUsbLine(
            lineReader,
            // Wir ziehen die relevanten USB-Zeilen heraus und lassen Debug-Text ignorieren.
            (payload) => payload.startsWith('OK READY') ||
                         payload.startsWith('OK START') ||
                         payload.startsWith('ERR'),
            6000
          );
        } catch (err) {
          usbLog('!!', `Keine START-Bestätigung innerhalb 6s: ${err?.message || err}`);
        }

        if (startAck) {
          usbLog('<=', startAck);
          if (startAck.startsWith('OK READY')) {
            usbLog('<>', 'READY bestätigt – warte auf OK START');
            try {
              startAck = await waitForUsbLine(
                lineReader,
                (payload) => payload.startsWith('OK START') || payload.startsWith('ERR'),
                6000
              );
              usbLog('<=', startAck);
            } catch (err) {
              usbLog('!!', `Kein OK START nach READY: ${err?.message || err}`);
            }
          }
        }

        if (startAck && startAck.startsWith('OK START')) {
          let deviceFilename = sanitizedName;
          const parts = startAck.split(/\s+/);
          if (parts.length >= 3) {
            deviceFilename = parts[2];
          }
          setUsbStatus(`Übertragung gestartet (${deviceFilename})`);
          usbLog('<>', `Transfer bestätigt: ${deviceFilename}`);
        } else if (startAck && startAck.startsWith('ERR')) {
          usbLog('!!', `Gerät meldet Fehler vor Datenstart: ${startAck}`);
          setUsbStatus(`Gerätefehler: ${startAck}`);
          throw new Error(startAck);
        } else {
          const noAckMsg = 'Keine START-Bestätigung vom Gerät empfangen. Bitte sicherstellen, dass der Transfer-Modus aktiv ist (BTN2 lang halten, bis "Transfer" erscheint).';
          usbLog('!!', noAckMsg);
          setUsbStatus(noAckMsg);
          throw new Error(noAckMsg);
        }

        // With RAM buffering (ESP32 commit 549e054), es kommen keine PROG-Meldungen während der Übertragung
        // Der ESP32 puffert alle Daten und sendet PROG erst nach END.

        sent = 0;
        setUsbStatus(`Sende Daten (${totalLabel})...`);
        usbLog('->', `DATA all ${totalSize} bytes`);
        await writer.write(bytes);
        sent = totalSize;
        usbLog('<>', 'Host finished writing to port');

        const expectedTransferTime = ((totalSize * 10) / 115200) * 1000;
        const waitTime = Math.max(1000, expectedTransferTime + 1000);
        setUsbStatus(`Warte auf ESP32-Empfang (~${Math.round(waitTime/1000)}s)...`);
        usbLog('<>', `Waiting ${Math.round(waitTime/1000)}s for ESP32 to receive data (transfer time: ${Math.round(expectedTransferTime/1000)}s + 1s margin)`);
        await delay(waitTime);

        setUsbStatus('Sende END-Kommando...');
        usbLog('->', 'END');
        await writer.write(textEncoder.encode('END\n'));

        const flashWriteTime = Math.ceil((totalSize / 512) * 2) + 2000;
        const endTimeout = Math.max(20000, flashWriteTime);
        usbLog('<>', `Waiting for END response (timeout: ${Math.round(endTimeout/1000)}s, flash write estimate: ${Math.round(flashWriteTime/1000)}s)`);

        const endPredicate = (payload) => {
          if (payload.startsWith('OK END')) {
            return true;
          }
          if (payload.startsWith('OK PROG')) {
            const parts = payload.split(/\s+/);
            if (parts.length >= 4) {
              const received = Number(parts[2]);
              const total = Number(parts[3]);
              if (Number.isFinite(received) && Number.isFinite(total) && total > 0 && received >= total) {
                return true;
              }
            }
          }
          return false;
        };

        const endAck = await waitForUsbLine(lineReader, endPredicate, endTimeout);
        if (endAck.startsWith('OK PROG')) {
          setUsbStatus('Übertragung abgeschlossen ✅ (Bestätigung über Fortschrittsmeldung)');
        } else {
          const endParts = endAck.split(/\s+/);
          if (endParts.length >= 3) {
            setUsbStatus(`Übertragung abgeschlossen ✅ (${endParts[2]})`);
          } else {
            setUsbStatus('Übertragung abgeschlossen ✅');
          }
        }
        transferCompleted = true;
      } catch (error) {
        console.error(error);
        const name = error?.name;
        let userMessage = '';
        let fetchLog = false;
        usbLog('<>', `HOST SENT ${sent}/${totalSize}`);

        if (name === 'NotFoundError') {
          setUsbStatus('USB-Senden abgebrochen – kein Port ausgewählt.');
          userMessage = 'USB-Senden abgebrochen – kein Port ausgewählt.';
        } else if (name === 'AbortError') {
          setUsbStatus('USB-Senden abgebrochen.');
          userMessage = 'USB-Senden abgebrochen.';
        } else if (name === 'NetworkError' || /device has been lost/i.test(error?.message || '')) {
          if (transferCompleted) {
            setUsbStatus('Übertragung abgeschlossen ✅ (Gerät hat den Port getrennt).');
            userMessage = '';
          } else {
            setUsbStatus('USB-Verbindung verloren – bitte Brosche neu verbinden und Transfer-Modus erneut aktivieren.');
            userMessage = 'USB-Verbindung verloren. Bitte den ESP32 neu verbinden, Transfer-Modus (BTN2 lang) aktivieren und erneut senden.';
            fetchLog = true;
          }
        } else if (/timeout beim warten/i.test(error?.message || '')) {
          setUsbStatus('Timeout – keine Antwort vom Gerät. Ist der Transfer-Modus aktiv (BTN2 lang in der Diashow)?');
          userMessage = 'Keine Antwort vom Gerät erhalten. Bitte sicherstellen, dass die Brosche im Transfer-Modus ist (BTN2 lang halten, bis "Transfer" angezeigt wird) und erneut versuchen.';
          fetchLog = true;
        } else {
          const message = error?.message || error?.toString() || 'Unbekannter Fehler';
          setUsbStatus(`Fehler: ${message}`);
          userMessage = 'Fehler beim USB-Senden: ' + message;
          fetchLog = true;
        }

        if (fetchLog && writer && lineReader) {
          try {
            await dumpDeviceLog(lineReader, writer, 20);
          } catch (logErr) {
            console.warn('Dump device log failed', logErr);
          }
        }

        if (userMessage) {
          await alertUsbError(userMessage);
        }
      } finally {
        try {
          if (writer) {
            usbLog('<>', 'release writer');
            await writer.releaseLock();
          }
        } catch (_) { /* ignore */ }
        try {
          if (reader) {
            usbLog('<>', 'cancel reader');
            await reader.cancel();
          }
        } catch (_) { /* ignore */ }
        try {
          if (readableClosed) {
            usbLog('<>', 'await readable close');
            await readableClosed.catch(() => {});
          }
        } catch (_) { /* ignore */ }
        try {
          if (port) {
            usbLog('<>', 'close port');
            await port.close();
          }
        } catch (_) { /* ignore */ }
        usbSending = false;
        updateActionButtons();
      }
    }

    async function sendViaBle() {
      if (!bleSupported) {
        alert('WebBluetooth wird von diesem Browser nicht unterstützt. Bitte Chrome, Edge oder Android Chrome verwenden.');
        return;
      }
      if (bleSending || usbSending) return;
      if (!qrCodeReady) {
        alert('Bitte zuerst einen QR-Code generieren.');
        return;
      }

      let device = null;
      let server = null;
      let control = null;
      let chunk = null;
      let notifyHandler = null;
      let startConfirmed = false;
      let remoteError = null;
      let remoteDone = false;

      try {
        bleSending = true;
        updateActionButtons();
        setBleStatus('QR-Code wird vorbereitet …');

        const { bytes, filename } = await encodeCurrentImage();
        const sanitizedName = sanitizeFilenameForTransfer(filename);

        setBleStatus('Bitte Brosche auswählen …');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Brosche' }],
          optionalServices: [BLE_UUIDS.service]
        });
        device.addEventListener('gattserverdisconnected', () => {
          if (!remoteDone) {
            setBleStatus('BLE-Verbindung getrennt');
          }
        });

        setBleStatus('Verbindung wird hergestellt …');
        server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_UUIDS.service);
        control = await service.getCharacteristic(BLE_UUIDS.control);
        chunk = await service.getCharacteristic(BLE_UUIDS.chunk);

        setBleStatus('Aktiviere Statusmeldungen …');
        try {
          await control.startNotifications();
        } catch (err) {
          throw new Error('startNotifications fehlgeschlagen: ' + (err?.message || err));
        }

        notifyHandler = (event) => {
          const value = event.target.value;
          const text = textDecoder.decode(value);
          if (!text) return;
          console.log('[BLE] Status', text);
          if (text.startsWith('OK:START')) {
            startConfirmed = true;
            setBleStatus(`Übertragung gestartet (${sanitizedName})`);
          } else if (text.startsWith('OK:PROG:')) {
            const parts = text.split(':');
            if (parts.length >= 4) {
              const received = Number(parts[2]) || 0;
              const total = Number(parts[3]) || 0;
              const pct = total ? Math.min(100, Math.round((received / total) * 100)) : 0;
              setBleStatus(`Brosche empfängt ${pct}% (${humanReadableSize(received)} / ${humanReadableSize(total)})`);
            }
          } else if (text.startsWith('OK:END')) {
            remoteDone = true;
            setBleStatus('Übertragung abgeschlossen.');
          } else if (text.startsWith('ERR:')) {
            remoteError = text.substring(4) || 'Unbekannter Fehler';
            setBleStatus(`Fehler vom Gerät: ${remoteError}`);
          }
        };
        control.addEventListener('characteristicvaluechanged', notifyHandler);

        const startPayload = `START:${bytes.length}:${sanitizedName}`;
        try {
          await writeBle(control, textEncoder.encode(startPayload));
        } catch (err) {
          throw new Error('START schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        const startOk = await waitFor(() => startConfirmed || remoteError, 2000);
        if (remoteError) throw new Error(remoteError);
        if (!startOk) {
          throw new Error('Keine Rückmeldung vom Gerät (BLE-Modus aktiv?).');
        }

        setBleStatus('Sende QR-Code-Daten …');
        const chunkSize = 20;
        for (let offset = 0; offset < bytes.length; offset += chunkSize) {
          const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
          try {
            await writeBle(chunk, slice);
          } catch (err) {
            throw new Error(`Chunk @${offset} (${slice.length} B) fehlgeschlagen: ${err?.message || err}`);
          }
          if (remoteError) break;
          if ((offset / chunkSize) % 24 === 0) {
            const sent = offset + slice.length;
            const percent = Math.min(100, Math.round((sent / bytes.length) * 100));
            setBleStatus(`Sende ${percent}% (${humanReadableSize(sent)} / ${humanReadableSize(bytes.length)})`);
          }
          await delay(4);
        }

        if (remoteError) throw new Error(remoteError);

        try {
          await writeBle(control, textEncoder.encode('END'));
        } catch (err) {
          throw new Error('END schreiben fehlgeschlagen: ' + (err?.message || err));
        }
        setBleStatus('Übertragung gesendet, warte auf Bestätigung …');
        await waitFor(() => remoteDone || remoteError, 3000);
        if (remoteError) throw new Error(remoteError);
        if (!remoteDone) {
          setBleStatus('QR-Code übertragen – Brosche sollte den QR-Code anzeigen.');
        }
      } catch (error) {
        console.error(error);
        const message = error?.message || error?.toString() || 'Unbekannter Fehler';
        setBleStatus(`Fehler: ${message}`);
        alert('Fehler beim BLE-Senden: ' + message);
      } finally {
        try {
          if (control && notifyHandler) {
            control.removeEventListener('characteristicvaluechanged', notifyHandler);
            await control.stopNotifications();
          }
        } catch (_) { /* noop */ }
        try {
          if (server?.connected) {
            server.disconnect();
          }
        } catch (_) { /* noop */ }
        bleSending = false;
        updateActionButtons();
      }
    }

    async function initMozIfNeeded() {
      if (moz) {
        mozReady = true;
        return true;
      }
      try {
        moz = await moduleFactory();
        console.log('MozJPEG (WASM) bereit.');
        mozReady = true;
        updateActionButtons();
        return true;
      } catch (err) {
        console.error(err);
        alert('Konnte MozJPEG-WASM nicht laden. Prüfe Internetverbindung oder nutze lokale Dateien in ./mozjpeg/');
        return false;
      }
    }

    // Event listeners
    qrTextInput.addEventListener('input', async () => {
      await generateQRCode();
    });

    codeColorInput.addEventListener('input', async () => {
      await generateQRCode();
    });

    bgColorInput.addEventListener('input', async () => {
      await generateQRCode();
    });

    if (invertColorsBtn) {
      invertColorsBtn.addEventListener('click', async () => {
        const currentCodeColor = codeColorInput.value;
        codeColorInput.value = bgColorInput.value;
        bgColorInput.value = currentCodeColor;
        await generateQRCode();
      });
    }

    // Zoom with mouse wheel
    cv.addEventListener('wheel', async (e) => {
      if (!qrCodeReady) return;
      e.preventDefault();

      const zoomFactor = 1.15;
      const delta = -Math.sign(e.deltaY);
      const newZoom = delta > 0 ? zoomScale * zoomFactor : zoomScale / zoomFactor;
      zoomScale = Math.max(0.1, Math.min(10.0, newZoom));

      await generateQRCode();
    }, { passive: false });

    // Pan with drag
    cv.addEventListener('pointerdown', (e) => {
      if (!qrCodeReady) return;
      e.preventDefault();
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      panStart = { x: panOffset.x, y: panOffset.y };
      cv.classList.add('dragging');
      try {
        cv.setPointerCapture(e.pointerId);
      } catch (_) { /* ignore */ }
    });

    cv.addEventListener('pointermove', async (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      panOffset.x = panStart.x + dx;
      panOffset.y = panStart.y + dy;
      await generateQRCode();
    });

    function endDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      cv.classList.remove('dragging');
      try {
        cv.releasePointerCapture(e.pointerId);
      } catch (_) { /* ignore */ }
    }

    cv.addEventListener('pointerup', endDrag);
    cv.addEventListener('pointercancel', endDrag);

    btnSave.addEventListener('click', async () => {
      if (bleSending || usbSending) return;
      btnSave.disabled = true;
      try {
        const { bytes, filename } = await encodeCurrentImage();
        const blob = new Blob([bytes], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename || 'qrcode-qr.jpg';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
      } finally {
        updateActionButtons();
      }
    });

    if (btnUsb) {
      btnUsb.addEventListener('click', (e) => {
        console.log('[DEBUG] USB-Button geklickt', e);
        sendViaUsb();
      });
      if (!secureContext) {
        btnUsb.title = 'WebSerial benötigt HTTPS oder localhost.';
        setUsbStatus('WebSerial benötigt eine sichere Herkunft. Bitte die Seite über https:// oder http://localhost ausliefern.');
      } else if (!serialAvailable) {
        btnUsb.title = 'WebSerial wird von diesem Browser nicht freigegeben.';
        setUsbStatus('WebSerial wird von diesem Browser/Profil nicht unterstützt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge auf dem Desktop.');
      }
    }

    btnBle.addEventListener('click', sendViaBle);

    if (!secureContext) {
      btnBle.title = 'WebBluetooth benötigt HTTPS oder localhost.';
      setBleStatus('WebBluetooth benötigt eine sichere Herkunft. Bitte die Seite über https:// oder http://localhost ausliefern.');
    } else if (!bleAvailable) {
      btnBle.title = 'WebBluetooth wird von diesem Browser nicht freigegeben.';
      setBleStatus('WebBluetooth wird von diesem Browser/Profil nicht unterstützt. Verwende eine aktuelle Chromium-Variante wie Chrome oder Edge.');
    }

    // Initialize
    await initMozIfNeeded();
    updateActionButtons();

    // Generate initial blank QR code
    ctx.fillStyle = bgColorInput.value;
    ctx.fillRect(0, 0, cv.width, cv.height);
  </script>
</body>
</html>

# Plugin System TODO - Phase 2 Implementation Roadmap

## üéØ Ziel

Dynamisches Laden von `.bin` Plugin-Dateien zur Laufzeit ohne Firmware-Neukompilierung.

## ‚úÖ Bereits erledigt (Phase 1)

- [x] AppAPI Function Table Interface (`Core/AppAPI.h`)
- [x] PluginAppVTable Definition
- [x] StaticPluginApp Wrapper (`Core/StaticPluginApp.h/cpp`)
- [x] Build-System f√ºr Plugins (`plugins/Makefile`)
- [x] Linker-Script (`plugins/plugin.ld`)
- [x] Runtime-Support (`plugins/runtime.c`)
- [x] HelloWorld Plugin statisch funktionsf√§hig
- [x] HelloWorldPlugin.cpp als `.bin` kompiliert (835 bytes)
- [x] Dokumentation (CLAUDE.md, README.md)

## üöß Phase 2: AKTUELLER STAND (2025-11-01)

### ‚úÖ Bereits implementiert seit letztem Update:

1. **VTable Relocation** ‚úÖ FERTIG
   - `Core/PluginApp.cpp::relocateVTable_()` implementiert
   - Konvertiert relative Offsets zu absoluten Adressen
   - Threshold-basiert (< 0x1000 = relative offset)

2. **Auto-Discovery** ‚úÖ FERTIG
   - `ESP32-BoardOS.ino::discoverPlugins()` implementiert
   - Scannt LittleFS:/apps/*.bin UND SD:/apps/*.bin
   - Maximale Plugins: 10 (MAX_DYNAMIC_PLUGINS)
   - L√§uft in loop() statt setup() (boot watchdog avoidance)

3. **Dual Filesystem Support** ‚úÖ FERTIG
   - LittleFS und SD card beide unterst√ºtzt
   - Priority: LittleFS first, dann SD fallback beim Lesen

4. **AppAPIImpl Refactoring** ‚úÖ FERTIG
   - `Core/AppAPIImpl.h/cpp` erstellt
   - Shared AppAPI instance f√ºr StaticPluginApp und PluginApp
   - Duplicate symbol errors gel√∂st

### ‚ö†Ô∏è KRITISCHE BLOCKER - Plugin l√§dt NICHT

**Serial Output zeigt:**
```
[Plugins] Found: SD:/apps/HelloWorld.bin
E (7378) task_wdt: esp_task_wdt_reset(707): task not found  (x100+)
Guru Meditation Error: Core 0 panic'ed (Cache error)
Debug exception reason: Stack canary watchpoint triggered (IDLE0)
```

**Problem-Analyse:**

1. **Kein PluginApp Serial Output** ‚ùå
   - Plugin discovery findet die Datei
   - ABER: PluginApp::loadPlugin_() gibt KEINEN Output
   - ‚Üí Crash VOR erstem Serial.println in loadPlugin_()

2. **Task Watchdog Errors**
   - `yield()` calls versuchen Task im Watchdog zu resetten
   - Task ist NICHT registriert im Task Watchdog
   - ‚Üí Alle yield() calls erzeugen Fehler

3. **Stack Overflow im IDLE Task**
   - "Stack canary watchpoint triggered (IDLE0)"
   - IDLE Task l√§uft auf Core 0
   - ‚Üí Irgendetwas √ºberschreibt IDLE Task Stack

4. **Zwei Watchdogs auf ESP32:**
   - **Task Watchdog (TWDT):** √úberwacht Task-Ausf√ºhrung
   - **Interrupt Watchdog (TG1WDT):** √úberwacht Interrupt-Blocking
   - Fr√ºhere Resets waren TG1WDT_SYS_RESET

**Versuchte L√∂sungen (alle gescheitert):**

- ‚ùå disableCore0WDT() / disableCore1WDT() ‚Üí Stack Overflow
- ‚ùå yield() calls √ºberall ‚Üí "task not found" spam
- ‚ùå setup() ‚Üí loop() move ‚Üí kein Unterschied
- ‚ùå Serial output reduzieren ‚Üí kein Unterschied
- ‚ùå Single file read statt chunks ‚Üí kein Unterschied
- ‚ùå MALLOC_CAP_IRAM_8BIT ‚Üí returns NULL (0 bytes free!)
- ‚ùå MALLOC_CAP_INTERNAL ‚Üí bekommt DRAM, execution unbekannt

**Memory Status:**
```
Free IRAM: 0 bytes (!!!)
Free DRAM: ~280KB
Flash Usage: 1300203 / 1310720 bytes (99%)
```

**Root Cause vermutlich:**
- IRAM komplett voll (99% Flash = kein IRAM mehr)
- Plugin kann nicht in IRAM geladen werden
- DRAM execution ungetestet (ESP32 hat I-Cache, k√∂nnte funktionieren)
- Watchdog disable destabilisiert System ‚Üí Stack Overflow

---

### üöß Phase 2: Verbleibende Aufgaben

### 1. IRAM Exhaustion Problem l√∂sen ‚≠ê KRITISCH

**Optionen:**

**Option A: Flash Usage reduzieren**
- Compiler optimizations pr√ºfen (-Os vs -O2)
- Unused code eliminieren
- Gro√üe Konstanten in Flash statt RAM

**Option B: DRAM Execution testen**
- ESP32 hat Instruction Cache
- DRAM k√∂nnte executable sein via I-Cache
- Test: Plugin in DRAM laden ohne Watchdog disable

**Option C: External RAM (PSRAM)**
- Hardware upgrade n√∂tig
- Nur wenn A+B scheitern

**N√§chster Test:**
```cpp
// Ohne Watchdog disable, direkt DRAM allocation
pluginMemory_ = heap_caps_malloc(pluginSize_, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
// Dann: relocate und function call testen
```

---

### 2. yield() Calls entfernen

**Problem:** Main Loop Task ist nicht im Task Watchdog registriert

**L√∂sung:**
- Alle `yield()` calls in PluginApp.cpp entfernen
- ODER: `esp_task_wdt_add(xTaskGetCurrentTaskHandle())` vor Loading
- ODER: Task Watchdog komplett ignorieren (scheint nicht der Haupt-Issue)

---

### 3. Plugin Auto-Discovery (TEILWEISE FERTIG)

**Was funktioniert:**
- ‚úÖ Findet `.bin` files in SD:/apps/
- ‚úÖ Versucht PluginApp zu erstellen

**Was fehlt:**
- ‚ùå Plugin l√§dt nicht (siehe Blocker oben)
- [ ] Error recovery wenn Plugin crash
- [ ] Memory leak prevention

---

---

### 4. Plugin Upload System

Plugins via USB/BLE hochladen (√§hnlich wie Bilder).

**Option A: Erweitere SerialImageTransfer**
```cpp
// Neuer Befehl: UPLOAD_PLUGIN <filename> <size>
// Upload zu /apps/<filename>.bin

void SerialImageTransfer::handlePluginUpload(const char* filename, size_t size) {
  String path = "/apps/";
  path += filename;
  if (!path.endsWith(".bin")) path += ".bin";

  // Upload wie bei Images
  // Nach Upload: AppManager neu scannen
}
```

**Option B: Separater PluginTransfer**
- Eigenes Protokoll
- Eigene BLE/Serial Handler
- Upload nur von `.bin` Dateien

**TODO:**
- [ ] Entscheidung A oder B
- [ ] Implementierung
- [ ] Web-Tool Update (Bildaufbereiter)
- [ ] Test: Upload ‚Üí Auto-Discovery ‚Üí Plugin l√§uft

**Dateien:**
- `Core/SerialImageTransfer.cpp` (Option A)
- `Core/PluginTransfer.h/cpp` (Option B)
- `tools/bildaufbereiter/index.html` (Web-Tool)

---

### 5. AppManager Erweiterungen

**Dynamisches Nachladen:**
```cpp
class AppManager {
public:
  void reloadPlugins(); // Rescan /apps/*.bin
  void unloadPlugin(const char* name); // Remove specific plugin
  void hotReload(); // Reload all dynamic plugins
};
```

**TODO:**
- [ ] Implement Plugin reload ohne Neustart
- [ ] Handle cleanup von alten Plugins
- [ ] UI f√ºr Plugin-Management (optional)

**Datei:** `Core/AppManager.h/cpp`

---

## üî¨ Testing & Validation

### Phase 2 Test-Checklist

- [ ] **Relocation Test**
  - [ ] HelloWorld.bin l√§dt erfolgreich
  - [ ] VTable korrekt relocatet
  - [ ] Alle Funktionen funktional

- [ ] **Memory Test**
  - [ ] Keine Leaks bei Load/Unload
  - [ ] Mehrere Plugins parallel
  - [ ] IRAM Limits respektiert

- [ ] **Discovery Test**
  - [ ] Findet alle `.bin` in `/apps/`
  - [ ] L√§dt nur valide Plugins
  - [ ] √úberspringt korrupte Files

- [ ] **Upload Test**
  - [ ] USB Upload funktioniert
  - [ ] BLE Upload funktioniert
  - [ ] Auto-Discovery nach Upload

- [ ] **Integration Test**
  - [ ] Plugin l√§uft stabil
  - [ ] Button Events funktionieren
  - [ ] App-Wechsel sauber
  - [ ] Shutdown/Init Cycle OK

---

## üêõ Bekannte Probleme & L√∂sungen

### Problem 1: IRAM Exhaustion ‚≠ê KRITISCH - AKTUELL
**Status:** Blockiert alle Plugin-Loading Tests
**Symptome:**
- Free IRAM: 0 bytes
- MALLOC_CAP_IRAM_8BIT returns NULL
- Flash usage: 99% (1300KB / 1310KB)
**Impact:** Plugin kann nicht in executable memory geladen werden
**M√∂gliche L√∂sungen:**
1. Compiler optimization tuning (-Os, LTO)
2. Code in Flash + IRAM_ATTR nur f√ºr hot paths
3. DRAM execution via I-Cache testen
4. Gr√∂√üere Apps auslagern zu Plugins (Platz schaffen)

### Problem 2: Stack Overflow beim Watchdog Disable ‚≠ê KRITISCH - AKTUELL
**Status:** Neue Entdeckung (2025-11-01)
**Symptome:**
- "Stack canary watchpoint triggered (IDLE0)"
- Cache error + Core 0 panic
- Tritt auf bei disableCore0WDT() / disableCore1WDT()
**Root Cause:** Unbekannt - m√∂glicherweise:
- Interrupt disable destabilisiert System
- SD card operations brauchen Interrupts
- IDLE Task wird durch disable-Calls korrumpiert
**Workaround:** Watchdog disable NICHT verwenden

### Problem 3: Task Watchdog "task not found"
**Status:** Nervend aber nicht kritisch
**Symptome:** `E (xxxx) task_wdt: esp_task_wdt_reset(707): task not found`
**Ursache:** Main loop task ist nicht im Task Watchdog registriert
**L√∂sung:** Alle `yield()` calls entfernen aus PluginApp.cpp

### Problem 4: VTable Relocation
**Status:** ‚úÖ GEL√ñST (2025-11-01)
**L√∂sung:** Implementiert in Core/PluginApp.cpp::relocateVTable_()

### Problem 5: String Handling
**Status:** Gel√∂st f√ºr Phase 2
**Problem:** Arduino `String` nicht in Plugins verf√ºgbar (nostdlib)
**L√∂sung:** Plugins benutzen nur const char* und AppAPI Funktionen

### Problem 6: No stdlib
**Status:** Gel√∂st f√ºr Phase 2
**Problem:** Keine `printf`, `sprintf` etc.
**L√∂sung:**
- runtime.c bietet memcpy/memset/memmove
- AppAPI bietet logging (logInfo, logError)

---

## üìä Gesch√§tzter Aufwand

| Task | Gesch√§tzter Aufwand | Priorit√§t |
|------|---------------------|-----------|
| Relocation implementieren | 2-3h | ‚≠ê‚≠ê‚≠ê Kritisch |
| PluginApp testen | 1h | ‚≠ê‚≠ê‚≠ê Hoch |
| Auto-Discovery | 1h | ‚≠ê‚≠ê Mittel |
| Upload System | 2-3h | ‚≠ê‚≠ê Mittel |
| AppManager Erweiterungen | 1h | ‚≠ê Niedrig |
| Tests & Debugging | 2-4h | ‚≠ê‚≠ê Mittel |

**Total:** ca. 9-14 Stunden

---

## üéì Technische Referenzen

### Linker & Relocation
- ESP-IDF Documentation: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/linker-script-generation.html
- Position Independent Code: https://wiki.osdev.org/Position_Independent_Code
- ELF Relocation: https://refspecs.linuxbase.org/elf/gabi4+/ch4.reloc.html

### ESP32 Memory
- IRAM vs DRAM: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/memory-types.html
- heap_caps: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/mem_alloc.html

---

## üöÄ Quick Start f√ºr Entwickler

### Jetzt testen (Static):
```bash
# 1. Plugin als static einbinden (funktioniert jetzt)
# Siehe Apps/HelloWorldApp.cpp

# 2. Build & Upload
arduino-cli compile ...
arduino-cli upload ...

# 3. Mit BTN1 zu "Hello World" App wechseln
```

### Phase 2 weitermachen:
```bash
# 1. Relocation implementieren
# ‚Üí Bearbeite Core/PluginApp.cpp

# 2. Plugin binary kompilieren
cd plugins
make HelloWorldPlugin

# 3. Binary auf ESP32 kopieren (manuell via LittleFS upload)
# ‚Üí Oder warten auf Upload-System

# 4. Test in ESP32-BoardOS.ino
```

---

## üìù Notizen

- **Performance:** PIC hat minimalen Overhead (~5-10%), akzeptabel
- **Size:** HelloWorld.bin ist 835 bytes - sehr kompakt!
- **API Stability:** AppAPI v1 ist stabil, versioniert
- **Future:** Mehr AppAPI Funktionen bei Bedarf (Filesystem, JSON, etc.)

---

**Letzte Aktualisierung:** 2025-11-01
**Status:** Phase 1 Complete ‚úÖ | Phase 2 In Progress üöß | **BLOCKER: IRAM Exhaustion**
